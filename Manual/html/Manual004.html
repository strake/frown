<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>



<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.08">
<LINK rel="stylesheet" type="text/css" href="Manual.css">
<TITLE>
Tour de Frown
</TITLE>
</HEAD>
<BODY >
<A HREF="Manual003.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="Manual005.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
<HR>

<H1 CLASS="chapter"><A NAME="htoc7">Chapter&nbsp;3</A>&nbsp;&nbsp;Tour de <FONT COLOR=purple>Frown</FONT></H1>

This chapter introduces <FONT COLOR=purple>Frown</FONT> by means of example.<BR>
<BR>
<A NAME="toc5"></A>
<H2 CLASS="section"><A NAME="htoc8">3.1</A>&nbsp;&nbsp;Preliminaries: monads</H2>

Some elementary knowledge of <I><FONT COLOR=maroon>monads</FONT></I> is helpful in order to
use <FONT COLOR=purple>Frown</FONT> effectively. For the most basic applications, however, one
can possibly do without. This section summarizes the relevant facts.<BR>
<BR>
In Haskell, the concept of a monad is captured by the following
class definition.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>class</B>&nbsp;<I>Monad</I></TT><TT>&nbsp;m&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;a&nbsp;-&gt;&nbsp;m&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&gt;&gt;=)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;m&nbsp;a&nbsp;-&gt;&nbsp;(a&nbsp;-&gt;&nbsp;m&nbsp;b)&nbsp;-&gt;&nbsp;m&nbsp;b</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&gt;&gt;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;m&nbsp;a&nbsp;-&gt;&nbsp;m&nbsp;b&nbsp;-&gt;&nbsp;m&nbsp;b</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;m&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;&gt;&gt;&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;m&nbsp;&gt;&gt;=&nbsp;const&nbsp;n</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;error&nbsp;s
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The essential idea of monads is to distinguish between
<I><FONT COLOR=maroon>computations</FONT></I> and <I><FONT COLOR=maroon>values</FONT></I>. This distinction is
reflected on the type level: an element of <TT>m&nbsp;a</TT> represents a
computation that yields a value of type <TT>a</TT>. The trivial or pure
computation that immediately returns the value <TT>a</TT> is denoted <TT>return&nbsp;a</TT>. The operator <TT>(&gt;&gt;=)</TT>, commonly called `bind', combines two
computations: <TT>m&nbsp;&gt;&gt;=&nbsp;k</TT> applies <TT>k</TT> to the result of the computation
<TT>m</TT>. The derived operation <TT>(&gt;&gt;)</TT> provides a handy shortcut if one is
not interested in the result of the first computation. Finally, the
operation <TT>fail</TT> is useful for signaling error conditions (a common
thing in parsing).<BR>
<BR>
Framing the concept of a monad as a type class is sensible for at
least two interrelated reasons. First, we can use the same names
(<TT>return</TT>, `<TT>&gt;&gt;=</TT>', and <TT>fail</TT>) for wildly different computational
structures.<SUP><A NAME="text2" HREF="#note2">1</A></SUP> Second, by overloading a function with
the monad class we effectively parameterize the function by
computational structures, that is, we can call the same function with
different instances of monads obtaining different computational
effects.<BR>
<BR>
The following instance declaration (<TT>Result.lhs</TT>) defines a simple
monad that we will use intensively in the sequel (the monad can be
seen as a simplified term implementation of the basic monad
operations).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Result</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>data</B>&nbsp;<I>Result</I></TT><TT>&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Return</I></TT><TT>&nbsp;a&nbsp;|&nbsp;<I>Fail</I></TT><TT>&nbsp;<I>String</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>deriving</B>&nbsp;(<I>Show</I></TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>instance</B>&nbsp;<I>Monad</I></TT><TT>&nbsp;<I>Result</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Return</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Fail</I></TT><TT>&nbsp;s&nbsp;&nbsp;&nbsp;&gt;&gt;=&nbsp;k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Fail</I></TT><TT>&nbsp;s</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Return</I></TT><TT>&nbsp;a&nbsp;&gt;&gt;=&nbsp;k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;k&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Fail</I></TT><TT>
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
In monad speak, this is an <I><FONT COLOR=maroon>exception monad</FONT></I>: a computation
in <TT><I>Result</I></TT> either succeeds gracefully yielding a value <TT>a</TT>
(represented by the term <TT><I>Return</I></TT><TT>&nbsp;a</TT>) or it fails with an error message
<TT>s</TT> (represented by <TT><I>Fail</I></TT><TT>&nbsp;s</TT>). That's all we initially need for
<FONT COLOR=purple>Frown</FONT>: parsing a given input either succeeds producing a semantic
value (sometimes called an attribution) or it fails (hopefully, with a
clear indication of the syntax error).<BR>
<BR>
<A NAME="toc6"></A>
<H2 CLASS="section"><A NAME="htoc9">3.2</A>&nbsp;&nbsp;Basic features</H2>


<H3 CLASS="subsection"><A NAME="htoc10">3.2.1</A>&nbsp;&nbsp;Pure grammars</H3>
<A NAME="sec:pure"></A>

Let's start with a simple example. The following complete <FONT COLOR=purple>Frown</FONT>
source file (<TT>Paren1.lg</TT><SUP><A NAME="text3" HREF="#note3">2</A></SUP>) defines the language of
well-balanced parentheses. The specification of the grammar is
enclosed in special curly braces `<TT>%{&nbsp;ldots&nbsp;}%</TT>'. The remainder
contains Haskell source code, that is, a module header and a function
declaration.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Paren</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Result</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;%{</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;'('&nbsp;|&nbsp;')';</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Nonterminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;paren;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;paren,&nbsp;'(',&nbsp;paren,&nbsp;')';</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;}%</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;fail&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The part enclosed in special curly braces comprises the typical
ingredients of a <I><FONT COLOR=maroon>context-free grammar</FONT></I>: a declaration of
the <I><FONT COLOR=maroon>terminal symbols</FONT></I>, a declaration of the
<I><FONT COLOR=maroon>nonterminal symbols</FONT></I>, and finally the
<I><FONT COLOR=maroon>productions</FONT></I> or <I><FONT COLOR=maroon>grammar rules</FONT></I>.<BR>
<BR>
In general, the terminal symbols are given by Haskell patterns of the
same type. Here, we have two character patterns of type <TT><I>Char</I></TT>.<BR>
<BR>
Nonterminals are just identifiers starting with a lower-case letter.
By convention, the first nonterminal is also the start symbol of
the grammar (this default can be overwritten, see&nbsp;Sec.&nbsp;<A HREF="#sec:multiple">3.2.7</A>).<BR>
<BR>
Productions have the general form <TT>n&nbsp;:&nbsp;v_1,&nbsp;ldots,&nbsp;v_k;</TT> where <TT>n</TT> is
a nonterminal and <TT>v_1</TT>, ..., <TT>v_k</TT> are symbols. Note that the
symbols are separated by commas and terminated by a semicolon. The
mandatory trailing semicolon helps to identify so-called
<I><FONT COLOR=maroon>&#1108;-productions</FONT></I>, productions with an empty right-hand
side, such as <TT>paren&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;;</TT>.<BR>
<BR>
As a shorthand, we allow to list several alternative right-hand sides
separated by a vertical bar. Thus, the above productions could have
been written more succinctly as

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;paren,&nbsp;'(',&nbsp;paren,&nbsp;')';
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The two styles can be arbitrarily mixed. In fact, it is not even
required that productions with the same left-hand side are grouped
together (though it is good style to do so).<BR>
<BR>
Now, assuming that the above grammar resides in a file called
<TT>Paren.g</TT> we can generate a Haskell parser by issuing the command
<BLOCKQUOTE CLASS="quote">
<TT>frown&nbsp;Paren.g</TT>
</BLOCKQUOTE>
This produces a Haskell source file named <TT>Paren.hs</TT> that contains
among other things the function

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;[<I>Char</I></TT><TT>]&nbsp;-&gt;&nbsp;m&nbsp;()&nbsp;,
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
which recognizes the language generated by the start symbol of the
same name. Specifically, if <TT>inp</TT> is a list of characters, then
<TT>paren&nbsp;inp</TT> is a computation that either succeeds indicating that
<TT>inp</TT> is a well-formed parentheses or fails indicating that <TT>inp</TT>
isn't well-formed. Here is a short interactive session using the
Haskell interpreter Hugs (type <TT>hugs&nbsp;Paren.hs</TT> at the command line).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Paren</I></TT><TT>&gt;&gt;&nbsp;paren&nbsp;"(())()"&nbsp;::&nbsp;<I>Result</I></TT><TT>&nbsp;()</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Return</I></TT><TT>&nbsp;()</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Paren</I></TT><TT>&gt;&gt;&nbsp;paren&nbsp;"(())("&nbsp;&nbsp;::&nbsp;<I>Result</I></TT><TT>&nbsp;()</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Fail</I></TT><TT>&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Note that we have to specify the result type of the expressions in
order to avoid an unresolved overloading error. Or to put it
differently, we have to specify the monad, in which the parsing
process takes place. Of course, we are free to assign <TT>paren</TT> a more
constrained type by placing an appropriate type signature in the
Haskell section of the grammar file:

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;[<I>Char</I></TT><TT>]&nbsp;-&gt;&nbsp;<I>Result</I></TT><TT>&nbsp;()&nbsp;.
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
By the way, since the nonterminal <TT>paren</TT> carries no semantic value,
the type of the computation is simply <TT><I>Result</I></TT><TT>&nbsp;()</TT> where the empty
tuple type `<TT>()</TT>' serves as a dummy type. In the next section we will
show how to add attributes or semantic values to nonterminals.<BR>
<BR>
Every once in a while parsing fails. In this case, <FONT COLOR=purple>Frown</FONT> calls a
user-supplied function named, well, <TT>frown</TT> (note that you must supply
this function). In our example, <TT>frown</TT> has type

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;[<I>Char</I></TT><TT>]&nbsp;-&gt;&nbsp;m&nbsp;a
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The error function <TT>frown</TT> is passed the remaining input as an
argument, that you can give an indication of the location of the
syntax error (more on error reporting in
Sec.&nbsp;<A HREF="#sec:error-reporting">3.3</A>). Note that <TT>frown</TT> must be polymorphic
in the result type.<BR>
<BR>
<DIV CLASS="flushleft"><B>Remark&nbsp;1</B>&nbsp;&nbsp;<EM>
 For those of you who are knowledgable and/or interested in
 LR&nbsp;parsing, Fig.&nbsp;</EM><A HREF="#fig:ex1"><EM>3.1</EM></A><EM> displays the Haskell file that is
 generated by <TT>frown&nbsp;Paren.g</TT></EM><SUP><A NAME="text4" HREF="#note4"><EM>3</EM></A></SUP><EM>. For each state <TT>i</TT> of the underlying
 LR</EM>(<EM>0</EM>)<EM> automaton, displayed in Fig.&nbsp;</EM><A HREF="#fig:auto1"><EM>3.2</EM></A><EM>,
 there is one function called <TT>parse_i</TT>. All these functions take two
 arguments: the remaining input and a stack that records the
 transitions of the LR</EM>(<EM>0</EM>)<EM> machine. The reader is
 invited to trace the parse of <TT>"(())()"</TT>.
</EM><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><EM>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
</EM><TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Paren</I></TT></EM><EM><TT>&nbsp;<B>where</B></TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Result</I></TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;</TT>{- frown :-( -}</EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;<B>data</B>&nbsp;<I>Stack</I></TT></EM><EM><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Empty</I></TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>T_1_2</I></TT></EM><EM><TT>&nbsp;<I>Stack</I></TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>T_2_3</I></TT></EM><EM><TT>&nbsp;<I>Stack</I></TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>T_2_5</I></TT></EM><EM><TT>&nbsp;<I>Stack</I></TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>T_4_5</I></TT></EM><EM><TT>&nbsp;<I>Stack</I></TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>T_4_6</I></TT></EM><EM><TT>&nbsp;<I>Stack</I></TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>T_5_4</I></TT></EM><EM><TT>&nbsp;<I>Stack</I></TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;<B>data</B>&nbsp;<I>Nonterminal</I></TT></EM><EM><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Paren</I></TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;paren&nbsp;tr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_1&nbsp;tr&nbsp;<I>Empty</I></TT></EM><EM><TT>&nbsp;&gt;&gt;=&nbsp;(\&nbsp;<I>Paren</I></TT></EM><EM><TT>&nbsp;-&gt;&nbsp;return&nbsp;())</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;parse_1&nbsp;ts&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_2&nbsp;ts&nbsp;(<I>T_1_2</I></TT></EM><EM><TT>&nbsp;st)</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;parse_2&nbsp;tr@[]&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_3&nbsp;tr&nbsp;(<I>T_2_3</I></TT></EM><EM><TT>&nbsp;st)</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;parse_2&nbsp;('('&nbsp;:&nbsp;tr)&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_5&nbsp;tr&nbsp;(<I>T_2_5</I></TT></EM><EM><TT>&nbsp;st)</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;parse_2&nbsp;ts&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;frown&nbsp;ts</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;parse_3&nbsp;ts&nbsp;(<I>T_2_3</I></TT></EM><EM><TT>&nbsp;(<I>T_1_2</I></TT></EM><EM><TT>&nbsp;st))&nbsp;&nbsp;=&nbsp;&nbsp;return&nbsp;<I>Paren</I></TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;parse_4&nbsp;('('&nbsp;:&nbsp;tr)&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_5&nbsp;tr&nbsp;(<I>T_4_5</I></TT></EM><EM><TT>&nbsp;st)</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;parse_4&nbsp;(')'&nbsp;:&nbsp;tr)&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_6&nbsp;tr&nbsp;(<I>T_4_6</I></TT></EM><EM><TT>&nbsp;st)</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;parse_4&nbsp;ts&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;frown&nbsp;ts</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;parse_5&nbsp;ts&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_4&nbsp;ts&nbsp;(<I>T_5_4</I></TT></EM><EM><TT>&nbsp;st)</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;parse_6&nbsp;ts&nbsp;(<I>T_4_6</I></TT></EM><EM><TT>&nbsp;(<I>T_5_4</I></TT></EM><EM><TT>&nbsp;(<I>T_2_5</I></TT></EM><EM><TT>&nbsp;(<I>T_1_2</I></TT></EM><EM><TT>&nbsp;st))))&nbsp;=&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_2&nbsp;ts&nbsp;(<I>T_1_2</I></TT></EM><EM><TT>&nbsp;st)</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;parse_6&nbsp;ts&nbsp;(<I>T_4_6</I></TT></EM><EM><TT>&nbsp;(<I>T_5_4</I></TT></EM><EM><TT>&nbsp;(<I>T_4_5</I></TT></EM><EM><TT>&nbsp;(<I>T_5_4</I></TT></EM><EM><TT>&nbsp;st))))</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_4&nbsp;ts&nbsp;(<I>T_5_4</I></TT></EM><EM><TT>&nbsp;st)</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;</TT>{- )-: frown -}</EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;frown&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;fail&nbsp;"syntax&nbsp;error"</TT></EM></TD>
</TR></TABLE><EM>

</TD></TR></TABLE><P>
<BR>
<BR>
</EM><DIV CLASS="center"><EM>Figure 3.1: </EM><A NAME="fig:ex1"></A><EM>A <FONT COLOR=purple>Frown</FONT></EM><EM> generated parser.</EM></DIV><BR>
<BR>
<EM>
</EM><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><EM>
</EM><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><EM>
</EM><DIV CLASS="center"><EM>
<IMG SRC="Manual001.gif">
</EM></DIV><EM>
<BR>
<BR>
</EM><DIV CLASS="center"><EM>Figure 3.2: </EM><A NAME="fig:auto1"></A><EM>The LR(0) automaton underlying the parser of Fig.&nbsp;</EM><A HREF="#fig:ex1"><EM>3.1</EM></A><EM>.</EM></DIV><BR>
<BR>
<EM>
</EM><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><EM>
</EM></DIV><BR>
<BR>

<H3 CLASS="subsection"><A NAME="htoc11">3.2.2</A>&nbsp;&nbsp;Attributes</H3>
<A NAME="sec:attributes"></A>

Now, let's augment the grammar of Sec.&nbsp;<A HREF="#sec:pure">3.2.1</A> by semantic
values (<TT>Paren2.lg</TT>). Often, the parser converts a given input into
some kind of tree representation (the so-called <I><FONT COLOR=maroon>abstract
syntax tree</FONT></I>). To represent nested parentheses we simply use binary
trees (an alternative employing <TT>n</TT>-ary trees is given in
Sec.&nbsp;<A HREF="Manual005.html#sec:irrefutable">4.1</A>).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Paren</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Result</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>data</B>&nbsp;<I>Tree</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Leaf</I></TT><TT>&nbsp;|&nbsp;<I>Fork</I></TT><TT>&nbsp;<I>Tree</I></TT><TT>&nbsp;<I>Tree</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>deriving</B>&nbsp;(<I>Show</I></TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;%{</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;'('&nbsp;|&nbsp;')';</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Nonterminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;paren&nbsp;{<I>Tree</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;&nbsp;{<I>Leaf</I></TT><TT>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Fork</I></TT><TT>&nbsp;t&nbsp;u}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;paren&nbsp;{t},&nbsp;'(',&nbsp;paren&nbsp;{u},&nbsp;')';</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;}%</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;fail&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Attributes are always given in curly braces. When we declare a
nonterminal, we have to specify the types of its attributes as in
<TT>paren&nbsp;{<I>Tree</I></TT><TT>}</TT>. The rules of the grammar can be seen as functions from
the right-hand side to the left-hand side. On the right-hand side,
Haskell variables are used to name the values of attributes. The
values of the attributes on the left-hand side are then given by
Haskell expressions, in which the variables of the right-hand side may
occur free. The Haskell expressions can be arbitrary, except that they
must not be layout-sensitive.<BR>
<BR>
In general, a nonterminal may have an arbitrary number of attributes
(see Sec.&nbsp;<A HREF="Manual005.html#sec:multattr">4.4</A> for an example). Note that <FONT COLOR=purple>Frown</FONT> only
supports so-called <I><FONT COLOR=maroon>synthesized attributes</FONT></I>
(<I><FONT COLOR=maroon>inherited attributes</FONT></I> can be simulated, however, with the
help of a reader monad, see Sec.&nbsp;<A HREF="#sec:reader">3.2.8</A>, or with functional
attributes, see Sec.&nbsp;<A HREF="Manual005.html#sec:inherited">4.2</A>).<BR>
<BR>
The parser generated by <FONT COLOR=purple>Frown</FONT> now has type

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;[<I>Char</I></TT><TT>]&nbsp;-&gt;&nbsp;m&nbsp;<I>Tree</I></TT><TT>&nbsp;.
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The following interactive session illustrates its use.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Paren</I></TT><TT>&gt;&gt;&nbsp;paren&nbsp;"(())()"&nbsp;::&nbsp;<I>Result</I></TT><TT>&nbsp;<I>Tree</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Return</I></TT><TT>&nbsp;(<I>Fork</I></TT><TT>&nbsp;(<I>Fork</I></TT><TT>&nbsp;<I>Leaf</I></TT><TT>&nbsp;(<I>Fork</I></TT><TT>&nbsp;<I>Leaf</I></TT><TT>&nbsp;<I>Leaf</I></TT><TT>))&nbsp;<I>Leaf</I></TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Paren</I></TT><TT>&gt;&gt;&nbsp;paren&nbsp;"(())("&nbsp;::&nbsp;<I>Result</I></TT><TT>&nbsp;<I>Tree</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Fail</I></TT><TT>&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>

<H3 CLASS="subsection"><A NAME="htoc12">3.2.3</A>&nbsp;&nbsp;Interfacing with a lexer</H3>
<A NAME="sec:lexer"></A>

The parsers of the two previous sections take a list of characters as
input. In practice, a parser usually does not work on character
streams directly. Rather, it is prefaced by a lexer that first
converts the characters into a list of so-called
<I><FONT COLOR=maroon>tokens</FONT></I>. The separation of the lexical analysis from the
syntax analysis usually leads to a clearer design and as a benevolent
side-effect it also improves efficiency (Sec.&nbsp;<A HREF="#sec:terminal2">3.4.2</A>
shows how to combine lexing and parsing in <FONT COLOR=purple>Frown</FONT>, though).<BR>
<BR>
A simple token type is shown in Fig&nbsp;<A HREF="#fig:terminal">3.3</A>
(<TT>Terminal1.lhs</TT>). (Note that the type comprises more constructors
than initially needed.)
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Terminal</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Maybe</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>data</B>&nbsp;<I>Op</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Plus</I></TT><TT>&nbsp;|&nbsp;<I>Minus</I></TT><TT>&nbsp;|&nbsp;<I>Times</I></TT><TT>&nbsp;|&nbsp;<I>Divide</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>deriving</B>&nbsp;(<I>Show</I></TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>Op</I></TT><TT>&nbsp;-&gt;&nbsp;<I>String</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;name&nbsp;<I>Plus</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;"+"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;name&nbsp;<I>Minus</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;"-"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;name&nbsp;<I>Times</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;"*"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;name&nbsp;<I>Divide</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;"/"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;app&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>Op</I></TT><TT>&nbsp;-&gt;&nbsp;(<I>Int</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Int</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Int</I></TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;app&nbsp;<I>Plus</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;(+)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;app&nbsp;<I>Minus</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;(-)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;app&nbsp;<I>Times</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;(*)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;app&nbsp;<I>Divide</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;div</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>data</B>&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Numeral</I></TT><TT>&nbsp;<I>Int</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;<I>String</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<I>Addop</I></TT><TT>&nbsp;<I>Op</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<I>Mulop</I></TT><TT>&nbsp;<I>Op</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<I>KWLet</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<I>KWIn</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<I>Equal</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<I>LParen</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<I>RParen</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<I>EOF</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>deriving</B>&nbsp;(<I>Show</I></TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;ident,&nbsp;numeral&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Terminal</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;ident&nbsp;&nbsp;&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;fromMaybe&nbsp;(<I>Ident</I></TT><TT>&nbsp;s)&nbsp;(lookup&nbsp;s&nbsp;keywords)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;numeral&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Numeral</I></TT><TT>&nbsp;(read&nbsp;s)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;keywords&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;[(<I>String</I></TT><TT>,&nbsp;<I>Terminal</I></TT><TT>)]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;keywords&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;[&nbsp;("let",&nbsp;<I>KWLet</I></TT><TT>),&nbsp;("in",&nbsp;<I>KWIn</I></TT><TT>)&nbsp;]
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<DIV CLASS="center">Figure 3.3: <A NAME="fig:terminal"></A>The type of terminals (<TT>Terminal1.lhs</TT>).</DIV><BR>
<BR>

<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
Fig.&nbsp;<A HREF="#fig:lexer">3.4</A> (<TT>Lexer.lhs</TT>) displays a simple lexer for
arithmetic expressions, which are built from numerals using the
arithmetic operators `<TT>+</TT>', `<TT>-</TT>', `<TT>*</TT>', and `<TT>/</TT>'.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Lexer</I></TT><TT>&nbsp;&nbsp;(<B>module</B>&nbsp;<I>Terminal</I></TT><TT>,&nbsp;<B>module</B>&nbsp;<I>Lexer</I></TT><TT>)&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Char</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Terminal</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lexer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;[<I>Terminal</I></TT><TT>]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lexer&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;[]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lexer&nbsp;('+'&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Addop</I></TT><TT>&nbsp;<I>Plus</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;lexer&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lexer&nbsp;('-'&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Addop</I></TT><TT>&nbsp;<I>Minus</I></TT><TT>&nbsp;&nbsp;&nbsp;:&nbsp;lexer&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lexer&nbsp;('*'&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Mulop</I></TT><TT>&nbsp;<I>Times</I></TT><TT>&nbsp;&nbsp;&nbsp;:&nbsp;lexer&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lexer&nbsp;('/'&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Mulop</I></TT><TT>&nbsp;<I>Divide</I></TT><TT>&nbsp;&nbsp;:&nbsp;lexer&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lexer&nbsp;('='&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Equal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;lexer&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lexer&nbsp;('('&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>LParen</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;lexer&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lexer&nbsp;(')'&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>RParen</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;lexer&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lexer&nbsp;(c&nbsp;:&nbsp;cs)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;isAlpha&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<B>let</B>&nbsp;(s,&nbsp;cs')&nbsp;=&nbsp;span&nbsp;isAlphaNum&nbsp;&nbsp;cs&nbsp;&nbsp;<B>in</B>&nbsp;&nbsp;ident&nbsp;&nbsp;&nbsp;&nbsp;(c&nbsp;:&nbsp;s)&nbsp;:&nbsp;lexer&nbsp;cs'</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;isDigit&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<B>let</B>&nbsp;(s,&nbsp;cs')&nbsp;=&nbsp;span&nbsp;isDigit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs&nbsp;&nbsp;<B>in</B>&nbsp;&nbsp;numeral&nbsp;&nbsp;(c&nbsp;:&nbsp;s)&nbsp;:&nbsp;lexer&nbsp;cs'</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;otherwise&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;lexer&nbsp;cs
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<DIV CLASS="center">Figure 3.4: <A NAME="fig:lexer"></A>A simple lexer for arithmetic expressions (<TT>Lexer.lhs</TT>).</DIV><BR>
<BR>

<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
The following grammar, which builds upon the lexer, implements a
simple evaluator for arithmetic expressions (<TT>Calc.lg</TT>).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Calc</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Lexer</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Result</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;%{</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Numeral</I></TT><TT>&nbsp;{<I>Int</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Addop</I></TT><TT>&nbsp;{<I>Op</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Mulop</I></TT><TT>&nbsp;{<I>Op</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>LParen</I></TT><TT>&nbsp;&nbsp;as&nbsp;"("</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>RParen</I></TT><TT>&nbsp;&nbsp;as&nbsp;")";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Nonterminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;expr&nbsp;{<I>Int</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;term&nbsp;{<I>Int</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;factor&nbsp;{<I>Int</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;&nbsp;&nbsp;{app&nbsp;op&nbsp;v1&nbsp;v2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;expr&nbsp;{v1},&nbsp;<I>Addop</I></TT><TT>&nbsp;{op},&nbsp;term&nbsp;{v2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;term&nbsp;{e};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;term&nbsp;&nbsp;&nbsp;&nbsp;{app&nbsp;op&nbsp;v1&nbsp;v2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;term&nbsp;{v1},&nbsp;<I>Mulop</I></TT><TT>&nbsp;{op},&nbsp;factor&nbsp;{v2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;factor&nbsp;{e};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;factor&nbsp;&nbsp;{n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;<I>Numeral</I></TT><TT>&nbsp;{n};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"(",&nbsp;expr&nbsp;{e},&nbsp;")";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;}%</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;fail&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The terminal declaration now lists patterns of type <TT><I>Terminal</I></TT>. Note
that terminals may also carry semantic values. The single argument of
<TT><I>Numeral</I></TT>, for instance, records the numerical value of the numeral.<BR>
<BR>
When declaring a terminal we can optionally define a shortcut using an
<TT>as</TT>-clause as, for example, in <TT><I>LParen</I></TT><TT>&nbsp;as&nbsp;"("</TT>. The shortcut can be
used in the productions possibly improving their readability.<BR>
<BR>
Here is an example session demonstrating the evaluator.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Calc</I></TT><TT>&gt;&gt;&nbsp;lexer&nbsp;"4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1)"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;[<I>Numeral</I></TT><TT>&nbsp;4,<I>Mulop</I></TT><TT>&nbsp;<I>Times</I></TT><TT>,<I>LParen</I></TT><TT>,<I>Numeral</I></TT><TT>&nbsp;7,<I>Addop</I></TT><TT>&nbsp;<I>Plus</I></TT><TT>,<I>Numeral</I></TT><TT>&nbsp;1,<I>RParen</I></TT><TT>]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Calc</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"4711")&nbsp;::&nbsp;<I>Result</I></TT><TT>&nbsp;<I>Int</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Return</I></TT><TT>&nbsp;4711</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Calc</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1)&nbsp;-&nbsp;1")&nbsp;::&nbsp;<I>Result</I></TT><TT>&nbsp;<I>Int</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Return</I></TT><TT>&nbsp;31</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Calc</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1")&nbsp;::&nbsp;<I>Result</I></TT><TT>&nbsp;<I>Int</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Fail</I></TT><TT>&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>

<H3 CLASS="subsection"><A NAME="htoc13">3.2.4</A>&nbsp;&nbsp;Monadic actions</H3>
<A NAME="sec:monadicactions"></A>

The expression that determines the value of an attribute is usually a
pure one. It is, however, also possible to provide a monadic action
that <EM>computes</EM> the value of the attribute. The computation lives
in the underlying parsing monad. Monadic actions are enclosed in `<TT>{%&nbsp;ldots&nbsp;}</TT>' braces and have type <TT>m&nbsp;t</TT> where <TT>m</TT> is the type of the
underlying monad and <TT>t</TT> is the type of attributes.<BR>
<BR>
As an example, the following variant of the desktop calculator
(<TT>MCalc.lg</TT>) prints all intermediate results (note that we only list
the changes to the preceeding example).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;trace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;<I>Op</I></TT><TT>&nbsp;-&gt;&nbsp;(<I>Int</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Int</I></TT><TT>&nbsp;-&gt;&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Int</I></TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;trace&nbsp;op&nbsp;v1&nbsp;v2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;putStrLn&nbsp;s&nbsp;&gt;&gt;&nbsp;return&nbsp;v</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>where</B>&nbsp;v&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;app&nbsp;op&nbsp;v1&nbsp;v2</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;show&nbsp;v1&nbsp;++&nbsp;name&nbsp;op&nbsp;++&nbsp;show&nbsp;v2&nbsp;++&nbsp;"="&nbsp;++&nbsp;show&nbsp;v
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;{%&nbsp;trace&nbsp;op&nbsp;v1&nbsp;v2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;expr&nbsp;{v1},&nbsp;<I>Addop</I></TT><TT>&nbsp;{op},&nbsp;term&nbsp;{v2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;term&nbsp;{%&nbsp;trace&nbsp;op&nbsp;v1&nbsp;v2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;term&nbsp;{v1},&nbsp;<I>Mulop</I></TT><TT>&nbsp;{op},&nbsp;factor&nbsp;{v2};
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The following session illustrates its working.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>MCalc</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"4711")</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;4711</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>MCalc</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1)&nbsp;-&nbsp;1")</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;7+1=8</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;4*8=32</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;32-1=31</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;31</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>MCalc</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1")</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;7+1=8</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;Program&nbsp;error:&nbsp;user&nbsp;error&nbsp;(syntax&nbsp;error)</TT><TT>
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
In general, monadic actions are useful for performing `side-effects' (for example,
in order to parse <TT>%include</TT> directives)
and for interaction with a monadic lexer (see Sec.&nbsp;<A HREF="#sec:mlexer">3.3.1</A>).<BR>
<BR>

<H3 CLASS="subsection"><A NAME="htoc14">3.2.5</A>&nbsp;&nbsp;Backtracking parsers</H3>
<A NAME="sec:backtracking"></A>

In the previous examples we have encoded the precedences of the
operators (`<TT>*</TT>' binds more tightly than `<TT>+</TT>') into the productions
of the grammar. However, this technique soon becomes unwieldy for a
larger expression language. So let's start afresh. The grammar file
shown in Fig.&nbsp;<A HREF="#fig:let1">3.5</A> (<TT>Let1.lg</TT>) uses only a single
nonterminal for expressions (we have also extended expressions by
local definitions).
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Let</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Lexer</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Monad</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>data</B>&nbsp;<I>Expr</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Const</I></TT><TT>&nbsp;<I>Int</I></TT><TT>&nbsp;|&nbsp;<I>Var</I></TT><TT>&nbsp;<I>String</I></TT><TT>&nbsp;|&nbsp;<I>Bin</I></TT><TT>&nbsp;<I>Expr</I></TT><TT>&nbsp;<I>Op</I></TT><TT>&nbsp;<I>Expr</I></TT><TT>&nbsp;|&nbsp;<I>Let</I></TT><TT>&nbsp;<I>Decl</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>deriving</B>&nbsp;(<I>Show</I></TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>data</B>&nbsp;<I>Decl</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>String</I></TT><TT>&nbsp;:=:&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>deriving</B>&nbsp;(<I>Show</I></TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;%{</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Numeral</I></TT><TT>&nbsp;{<I>Int</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;{<I>String</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Addop</I></TT><TT>&nbsp;{<I>Op</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Mulop</I></TT><TT>&nbsp;{<I>Op</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>KWLet</I></TT><TT>&nbsp;&nbsp;&nbsp;as&nbsp;"let"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>KWIn</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"in"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Equal</I></TT><TT>&nbsp;&nbsp;&nbsp;as&nbsp;"="</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>LParen</I></TT><TT>&nbsp;&nbsp;as&nbsp;"("</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>RParen</I></TT><TT>&nbsp;&nbsp;as&nbsp;")";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;{<I>Expr</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;{<I>Const</I></TT><TT>&nbsp;n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;<I>Numeral</I></TT><TT>&nbsp;{n};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Var</I></TT><TT>&nbsp;s}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;{s};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Bin</I></TT><TT>&nbsp;e1&nbsp;op&nbsp;e2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;expr&nbsp;{e1},&nbsp;<I>Addop</I></TT><TT>&nbsp;{op},&nbsp;expr&nbsp;{e2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Bin</I></TT><TT>&nbsp;e1&nbsp;op&nbsp;e2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;expr&nbsp;{e1},&nbsp;<I>Mulop</I></TT><TT>&nbsp;{op},&nbsp;expr&nbsp;{e2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Let</I></TT><TT>&nbsp;d&nbsp;e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"let",&nbsp;decl&nbsp;{d},&nbsp;"in",&nbsp;expr&nbsp;{e};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"(",&nbsp;expr&nbsp;{e},&nbsp;")";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;decl&nbsp;&nbsp;{<I>Decl</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;decl&nbsp;&nbsp;{s&nbsp;:=:&nbsp;e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;{s},&nbsp;"=",&nbsp;expr&nbsp;{e};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;}%</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;fail&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<DIV CLASS="center">Figure 3.5: <A NAME="fig:let1"></A>An ambiguous grammar (<TT>Let1.lg</TT>).</DIV><BR>
<BR>

<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
Also note that the grammar has no <TT><I>Nonterminal</I></TT> declaration. Rather,
the terminal symbols are declared by supplying type signatures before
the respective rules. Generally, type signatures are preferable to a
<TT><I>Nonterminal</I></TT> declaration if the grammar is long.<BR>
<BR>
Of course, the rewritten grammar is no longer LALR(<I>k</I>) simply because
it is ambiguous. For instance, `<TT>1+2*3</TT>' can be parsed as <TT><I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3))</TT> or as <TT><I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2))&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3)</TT>. <FONT COLOR=purple>Frown</FONT> is also unhappy with the
grammar: it reports six shift/reduce conflicts:
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&nbsp;*&nbsp;warning:&nbsp;6&nbsp;shift/reduce&nbsp;conflicts
</TT></TD>
</TR></TABLE>
This means that <FONT COLOR=purple>Frown</FONT> wasn't able to produce a deterministic parser.
Or rather, it produced a deterministic parser by making some arbitrary
choices to avoid non-determinism (shifts are preferred to reductions,
see Sec.&nbsp;<A HREF="#sec:prec">3.2.6</A>). However, we can also instruct <FONT COLOR=purple>Frown</FONT> to
produce a non-deterministic parser, that is, one that generates all
possible parses of a given input. We do so by supplying the option
<TT>--backtrack</TT>:
<BLOCKQUOTE CLASS="quote">
<TT>frown&nbsp;--backtrack&nbsp;Let.g</TT>
</BLOCKQUOTE>
The generated parser <TT>expr</TT> now has type

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;(<I>MonadPlus</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;[<I>Terminal</I></TT><TT>]&nbsp;-&gt;&nbsp;m&nbsp;<I>Expr</I></TT><TT>&nbsp;.
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Note that the underlying monad must be an instance of <TT><I>MonadPlus</I></TT>
(defined in the standard library <TT><I>Monad</I></TT>). The list monad and the
<TT><I>Maybe</I></TT> monad are both instances of <TT><I>MonadPlus</I></TT>. The following session
shows them in action.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"1&nbsp;+&nbsp;2&nbsp;-&nbsp;3&nbsp;*&nbsp;4&nbsp;/&nbsp;5")&nbsp;::&nbsp;[<I>Expr</I></TT><TT>]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;[<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2)&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5)))),<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2)&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4))&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5))),<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2)&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)))&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5)),<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2)&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4))))&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5),<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2)&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3))&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5))),<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2)&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3))&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4))&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5)),<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2)&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3))&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)))&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5),<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2)&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3)))&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5)),<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2)&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3)))&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4))&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5),<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5))),<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4))&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5)),<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)))&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5),<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3))&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5)),<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3))&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4))&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5)]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"1&nbsp;+&nbsp;-&nbsp;3&nbsp;*&nbsp;4&nbsp;/&nbsp;5")&nbsp;::&nbsp;[<I>Expr</I></TT><TT>]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;[]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"1&nbsp;+&nbsp;2&nbsp;-&nbsp;3&nbsp;*&nbsp;4&nbsp;/&nbsp;5")&nbsp;::&nbsp;<I>Maybe</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Just</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2)&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5)))))
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The list monad supports `deep backtracking': all possible parses are
returned (beware: the number grows exponentionally). The <TT><I>Maybe</I></TT> monad
implements `shallow backtracking': it commits to the first solution
(yielding the same results as the parser generated <EM>without</EM> the
option <TT>--backtrack</TT>).<BR>
<BR>

<H3 CLASS="subsection"><A NAME="htoc15">3.2.6</A>&nbsp;&nbsp;Precedences and associativity</H3>
<A NAME="sec:prec"></A>

Instead of resorting to a backtracking parser we may also help <FONT COLOR=purple>Frown</FONT> 
to generate the `right' deterministic parser by assigning
<I><FONT COLOR=maroon>precedences</FONT></I> to terminal symbols. The understand the
working of precedences it is necessary to provide some background of
the underlying parsing technique.<BR>
<BR>
LR parsers work by repeatedly performing two operations:
<I><FONT COLOR=maroon>shifts</FONT></I> and <I><FONT COLOR=maroon>reductions</FONT></I>. A shift moves a
terminal from the input onto the stack, the auxiliary data structure
maintained by the parser. A reduction replaces a top segment of the
stack matching the right-hand side of a production by its left-hand side.
Parsing succeeds if the input is empty and the stack consists of a
start symbol only. As an example, consider parsing `<TT><I>N</I></TT><TT>*<I>N</I></TT><TT>+<I>N</I></TT>'.
<DIV CLASS="center"><TABLE CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=middle><TD NOWRAP >
</TD>
<TD NOWRAP><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=right NOWRAP><I>N</I>*<I>N</I>+<I>N</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>shift</I></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>N</I></TD>
<TD ALIGN=right NOWRAP>*<I>N</I>+<I>N</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>reduce</I> <I>by</I> <TT><I>e</I>&nbsp;:&nbsp;</TT><TT><I> <I>N</I></I></TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I></TD>
<TD ALIGN=right NOWRAP>*<I>N</I>+<I>N</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>shift</I></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I>*</TD>
<TD ALIGN=right NOWRAP><I>N</I>+<I>N</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>shift</I></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I>*<I>N</I></TD>
<TD ALIGN=right NOWRAP>+<I>N</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>reduce</I> <I>by</I> <TT><I>e</I>&nbsp;:&nbsp;</TT><TT><I> <I>N</I></I></TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I>*<I>e</I></TD>
<TD ALIGN=right NOWRAP>+<I>N</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR></TABLE></TD>
</TR></TABLE></DIV>
At this point, there are two possibilities: we can either perform a
reduction (using the production <TT>e&nbsp;:&nbsp;e,&nbsp;*,&nbsp;e;</TT>) or shift the next
input symbol. Both choices are viable.
<DIV CLASS="center"><TABLE CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=middle><TD NOWRAP >
</TD>
<TD NOWRAP><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1>
<TR><TD ALIGN=right NOWRAP><I>e</I>*<I>e</I></TD>
<TD ALIGN=right NOWRAP>+<I>N</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>reduce</I> <I>by</I> <TT><I>e</I>&nbsp;:&nbsp;<I>e</I>,&nbsp;*,&nbsp;<I>e</I>;</TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I></TD>
<TD ALIGN=right NOWRAP>+<I>N</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>shift</I></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I>+</TD>
<TD ALIGN=right NOWRAP><I>N</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>shift</I></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I>+<I>N</I></TD>
<TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>reduce</I> <I>by</I> <TT><I>e</I>&nbsp;:&nbsp;</TT><TT><I> <I>N</I></I></TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I>+<I>e</I></TD>
<TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>reduce</I> <I>by</I> <TT><I>e</I>&nbsp;:&nbsp;<I>e</I>,&nbsp;+,&nbsp;<I>e</I>;</TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I></TD>
<TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR></TABLE></TD>
<TD NOWRAP>
&nbsp;&nbsp;&nbsp;&nbsp;
</TD>
<TD NOWRAP><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1>
<TR><TD ALIGN=right NOWRAP><I>e</I>*<I>e</I></TD>
<TD ALIGN=right NOWRAP>+<I>N</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>shift</I></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I>*<I>e</I>+</TD>
<TD ALIGN=right NOWRAP><I>N</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>shift</I></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I>*<I>e</I>+<I>N</I></TD>
<TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>reduce</I> <I>by</I> <TT><I>e</I>&nbsp;:&nbsp;</TT><TT><I> <I>N</I></I></TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I>*<I>e</I>+<I>e</I></TD>
<TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>reduce</I> <I>by</I> <TT><I>e</I>&nbsp;:&nbsp;<I>e</I>,&nbsp;+,&nbsp;<I>e</I>;</TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I>*<I>e</I></TD>
<TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>reduce</I> <I>by</I> <TT><I>e</I>&nbsp;:&nbsp;<I>e</I>,&nbsp;*&nbsp;,&nbsp;<I>e</I>;</TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I></TD>
<TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR></TABLE></TD>
</TR></TABLE></DIV>
Alas, the two choices also result in different parse trees. By default,
<FONT COLOR=purple>Frown</FONT> prefers shifts to reductions. As a consequence, <TT><I>N</I></TT><TT>*<I>N</I></TT><TT>+<I>N</I></TT> is parsed
as <TT><I>N</I></TT><TT>*(<I>N</I></TT><TT>+<I>N</I></TT><TT>)</TT>, that is, `<TT>+</TT>' binds more tightly than `<TT>*</TT>'.<BR>
<BR>
Now, we can direct the resolution of conflicts by assigning
<I><FONT COLOR=maroon>precedences</FONT></I> and <I><FONT COLOR=maroon>associativity</FONT></I> to terminal
symbols. The following declarations will do in our example (<TT>Let2.g</TT>).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;left&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;<I>Addop</I></TT><TT>&nbsp;{};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;left&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;<I>Mulop</I></TT><TT>&nbsp;{};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;nonassoc&nbsp;0&nbsp;"in";
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Thus, `<TT>*</TT>' takes precedence over `<TT>+</TT>', which in turn binds more
tightly than `<TT><B>in</B></TT>'. For instance, <TT><B>let</B>&nbsp;a&nbsp;=&nbsp;4&nbsp;<B>in</B>&nbsp;a&nbsp;+&nbsp;2</TT> is parsed as
<TT><B>let</B>&nbsp;a&nbsp;=&nbsp;4&nbsp;<B>in</B>&nbsp;(a&nbsp;+&nbsp;2)</TT>. A conflict between two symbols of equal
precedence is resolved using <I><FONT COLOR=maroon>associativity</FONT></I>: the succession
<TT>1+2+3</TT> of left-associative operators is grouped as <TT>(1+2)+3</TT>;
likewise for right-associative operators; sequences of non-associative
operators are not well-formed.<BR>
<BR>
Given the fixity declarations above <FONT COLOR=purple>Frown</FONT> now produces the `right'
deterministic parser, which can be seen in action below.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1)&nbsp;-&nbsp;1")&nbsp;::&nbsp;<I>Result</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Return</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;7)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"4&nbsp;*&nbsp;7&nbsp;+&nbsp;1&nbsp;-&nbsp;1")&nbsp;::&nbsp;<I>Result</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Return</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;7))&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1)&nbsp;-&nbsp;1\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a")&nbsp;::&nbsp;<I>Result</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Return</I></TT><TT>&nbsp;(<I>Let</I></TT><TT>&nbsp;("a"&nbsp;:=:&nbsp;<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;7)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1))&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a")&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a")))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a")&nbsp;::&nbsp;<I>Result</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Fail</I></TT><TT>&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
In general, a conflict between the actions `reduce by rule <TT>r</TT>' and
`shift terminal <TT>t</TT>' is resolved as follows (the precedence of a rule
is given by the precedence of the rightmost terminal on the right-hand
side):
<DIV CLASS="center">
<TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD BGCOLOR=black COLSPAN=5><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD BGCOLOR=black COLSPAN=5><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>condition</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>action</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP>example</TD>
</TR>
<TR><TD BGCOLOR=black COLSPAN=5><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD BGCOLOR=black COLSPAN=5><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>prec&nbsp;r&nbsp;&lt;&nbsp;prec&nbsp;t</TT></TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>shift</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP>reduce by <TT>e:e,+,e;</TT> versus shift <TT>*</TT></TD>
</TR>
<TR><TD BGCOLOR=black COLSPAN=5><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP><TT>left&nbsp;t</TT></TD>
<TD ALIGN=left NOWRAP>reduce</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP>reduce by <TT>e:e,*,e;</TT> versus shift <TT>*</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>prec&nbsp;r&nbsp;=&nbsp;prec&nbsp;t</TT></TD>
<TD ALIGN=left NOWRAP><TT>right&nbsp;t</TT></TD>
<TD ALIGN=left NOWRAP>shift</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP>reduce by <TT>e:e,++,e;</TT> versus shift <TT>++</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP><TT>nonassoc&nbsp;t</TT></TD>
<TD ALIGN=left NOWRAP>fail</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP>reduce by <TT>e:e,==,e;</TT> versus shift <TT>==</TT></TD>
</TR>
<TR><TD BGCOLOR=black COLSPAN=5><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>prec&nbsp;r&nbsp;&gt;&nbsp;prec&nbsp;t</TT></TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>reduce</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP>reduce by <TT>e:e,*,e;</TT> versus shift <TT>+</TT></TD>
</TR>
<TR><TD BGCOLOR=black COLSPAN=5><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD BGCOLOR=black COLSPAN=5><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR></TABLE>
</DIV><BR>
<BR>
Just in case you may wonder: there are no shift/shift conflicts by
construction; reduce/reduce conflicts cannot be cured using
precedences and associativity.<BR>
<BR>

<H3 CLASS="subsection"><A NAME="htoc16">3.2.7</A>&nbsp;&nbsp;Multiple start symbols</H3>
<A NAME="sec:multiple"></A>

A grammar may have several start symbols. In this case, <FONT COLOR=purple>Frown</FONT> 
generates multiple parsers, one for each start symbol (actually, these
are merely different entry points into the LR(0)
automaton<SUP><A NAME="text5" HREF="#note5">4</A></SUP>). We mark a symbol as a start symbol simply by putting
an asterix before its declaration (either in a <TT><I>Nonterminal</I></TT>
declaration or in a separate type signature). Consider our previous
example: most likely we want parsers both for expressions and
declarations. Thus, we write

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;*expr&nbsp;&nbsp;{<I>Expr</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;*decl&nbsp;&nbsp;{<I>Decl</I></TT><TT>};
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
and get parsers of type.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;[<I>Terminal</I></TT><TT>]&nbsp;-&gt;&nbsp;m&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;decl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;[<I>Terminal</I></TT><TT>]&nbsp;-&gt;&nbsp;m&nbsp;<I>Decl</I></TT><TT>&nbsp;.
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>

<H3 CLASS="subsection"><A NAME="htoc17">3.2.8</A>&nbsp;&nbsp;Monadic attributes</H3>
<A NAME="sec:reader"></A>

This section does not introduce any new features of <FONT COLOR=purple>Frown</FONT> and can be
safely skipped on first reading. Its purpose is to show how to
simulate inherited attributes using a reader monad (see also
Sec.&nbsp;<A HREF="Manual005.html#sec:inherited">4.2</A>). Generally, inherited attributes are used to
pass context information down the parse tree. As an example, consider
implementing an evaluator for arithmetic expressions that include
variables and <TT><B>let</B></TT>-bindings (<TT>Let3.lg</TT>). To determine the value of a
variable we need to pass down an environment that records the values
of bound variables. The reader monad displayed in Fig.&nbsp;<A HREF="#fig:reader">3.6</A>
(<TT>Reader.lhs</TT>) serves exactly this purpose.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Reader</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>newtype</B>&nbsp;<I>Reader</I></TT><TT>&nbsp;env&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Reader</I></TT><TT>&nbsp;{&nbsp;apply&nbsp;::&nbsp;env&nbsp;-&gt;&nbsp;a&nbsp;}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>instance</B>&nbsp;<I>Monad</I></TT><TT>&nbsp;(<I>Reader</I></TT><TT>&nbsp;env)&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Reader</I></TT><TT>&nbsp;(\&nbsp;env&nbsp;-&gt;&nbsp;a)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;&gt;&gt;=&nbsp;k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Reader</I></TT><TT>&nbsp;(\&nbsp;env&nbsp;-&gt;&nbsp;apply&nbsp;(k&nbsp;(apply&nbsp;m&nbsp;env))&nbsp;env)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Reader</I></TT><TT>&nbsp;(error&nbsp;s)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;getenv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>Reader</I></TT><TT>&nbsp;env&nbsp;env</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;getenv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Reader</I></TT><TT>&nbsp;(\&nbsp;env&nbsp;-&gt;&nbsp;env)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;withenv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;env&nbsp;-&gt;&nbsp;<I>Reader</I></TT><TT>&nbsp;env&nbsp;a&nbsp;-&gt;&nbsp;<I>Reader</I></TT><TT>&nbsp;env'&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;withenv&nbsp;env&nbsp;m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Reader</I></TT><TT>&nbsp;(\&nbsp;env'&nbsp;-&gt;&nbsp;apply&nbsp;m&nbsp;env)
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<DIV CLASS="center">Figure 3.6: <A NAME="fig:reader"></A>The reader monad (<TT>Reader.lhs</TT>).</DIV><BR>
<BR>

<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
We need some additional helper functions for accessing and
extending environments

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>type</B>&nbsp;<I>Binding</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;(<I>String</I></TT><TT>,&nbsp;<I>Int</I></TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>type</B>&nbsp;<I>Result</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Reader</I></TT><TT>&nbsp;[<I>Binding</I></TT><TT>]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;extend&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>Binding</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Result</I></TT><TT>&nbsp;a&nbsp;-&gt;&nbsp;<I>Result</I></TT><TT>&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;extend&nbsp;b&nbsp;m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;getenv&nbsp;&gt;&gt;=&nbsp;\&nbsp;env&nbsp;-&gt;&nbsp;withenv&nbsp;(b&nbsp;:&nbsp;env)&nbsp;m</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;access&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Result</I></TT><TT>&nbsp;<I>Int</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;access&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;getenv&nbsp;&gt;&gt;=&nbsp;\&nbsp;env&nbsp;-&gt;&nbsp;return&nbsp;(fromMaybe&nbsp;0&nbsp;(lookup&nbsp;s&nbsp;env))
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The following grammar implements the desired evaluator.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;{<I>Result</I></TT><TT>&nbsp;<I>Int</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;{<B>do</B>&nbsp;{b&nbsp;&lt;-&nbsp;d;&nbsp;extend&nbsp;b&nbsp;m}}&nbsp;&nbsp;:&nbsp;&nbsp;"let",&nbsp;decl&nbsp;{d},&nbsp;"in",&nbsp;expr&nbsp;{m};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{liftM2&nbsp;(app&nbsp;op)&nbsp;m1&nbsp;m2}&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;expr&nbsp;{m1},&nbsp;<I>Addop</I></TT><TT>&nbsp;{op},&nbsp;expr&nbsp;{m2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{liftM2&nbsp;(app&nbsp;op)&nbsp;m1&nbsp;m2}&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;expr&nbsp;{m1},&nbsp;<I>Mulop</I></TT><TT>&nbsp;{op},&nbsp;expr&nbsp;{m2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{return&nbsp;n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Numeral</I></TT><TT>&nbsp;{n};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{access&nbsp;s}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;{s};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{m}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"(",&nbsp;expr&nbsp;{m},&nbsp;")";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;decl&nbsp;&nbsp;{<I>Result</I></TT><TT>&nbsp;<I>Binding</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;decl&nbsp;&nbsp;{<B>do</B>&nbsp;{v&nbsp;&lt;-&nbsp;m;&nbsp;return&nbsp;(s,v)}}&nbsp;&nbsp;:&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;{s},&nbsp;"=",&nbsp;expr&nbsp;{m};
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Note that there are two monads around: the parsing monad (in fact,
<TT>expr</TT> is parametric in this monad) and the reader monad, which is
embedded in the attributes. The parser returns a value of type <TT><I>Reader</I></TT><TT>&nbsp;<I>Int</I></TT>, to which we pass an empty initial environment.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;eval&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;[<I>Char</I></TT><TT>]&nbsp;-&gt;&nbsp;m&nbsp;<I>Int</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;eval&nbsp;inp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<B>do</B>&nbsp;{f&nbsp;&lt;-&nbsp;expr&nbsp;(lexer&nbsp;inp);&nbsp;return&nbsp;(apply&nbsp;f&nbsp;[])}</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Let's see the evaluator in action.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;eval&nbsp;"2&nbsp;+&nbsp;7"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Int</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;9</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;eval&nbsp;"a&nbsp;+&nbsp;b"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Int</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;0</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;eval&nbsp;"let&nbsp;x&nbsp;=&nbsp;4&nbsp;in&nbsp;x&nbsp;*&nbsp;x"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Int</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;16</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;eval&nbsp;"let&nbsp;x&nbsp;=&nbsp;4&nbsp;in&nbsp;x&nbsp;*&nbsp;x&nbsp;+&nbsp;x"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Int</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;20</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;eval&nbsp;"(let&nbsp;x&nbsp;=&nbsp;4&nbsp;in&nbsp;x&nbsp;*&nbsp;x)&nbsp;+&nbsp;x"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Int</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;16
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<A NAME="toc7"></A>
<H2 CLASS="section"><A NAME="htoc18">3.3</A>&nbsp;&nbsp;Error reporting and correction</H2>
<A NAME="sec:error-reporting"></A>


<H3 CLASS="subsection"><A NAME="htoc19">3.3.1</A>&nbsp;&nbsp;Monadic lexers</H3>
<A NAME="sec:mlexer"></A>

The chances that parsing succeeds are probably smaller than the
chances that it fails. Good error messages are indispensable to turn
the latter into the former case. Up to now we only produced the rather
uninformative message <TT>"syntax&nbsp;error"</TT>. Fortunately, we are in a good
position to do better. LR parsing has the nice property that it
detects a syntax error at the earliest possible moment: parsing fails
as soon as the input cannot be extended to a legal sentence of the
grammar. For instance, the syntax error in <TT><B> <I>let</I></B></TT>&nbsp; <I>a</I> = 4 * (7 + 1 &minus;
1&nbsp;<TT><B> <I>in</I></B></TT>&nbsp;<I>a</I> * <I>a</I> is detected after reading the keyword `<TT><B>in</B></TT>'.<BR>
<BR>
Now, all we have to do is to keep track of context information: the
current line and column number and possibly the filename. This section
prepares the ground for maintaining state information; the parser that
actually keeps track of line numbers etc is only shown in the next
section.<BR>
<BR>
Unsurprisingly, to maintain state information we employ monads again.
This time, we require a state monad. The natural place for maintaining
information about line numbers etc is, of course, the lexer.
Consequently, we turn the stream-based lexer of type <TT><I>String</I></TT><TT>&nbsp;-&gt;&nbsp;[<I>Terminal</I></TT><TT>]</TT> into a monadic one of type

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;get&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;<I>M</I></TT><TT>&nbsp;<I>Terminal</I></TT><TT>
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
where <TT><I>M</I></TT> is the state monad. The idea is that each time <TT>get</TT> is
called it returns the next token and updates its internal state.<BR>
<BR>
The first version of the monadic lexer shown in Fig.&nbsp;<A HREF="#fig:mlexer1">3.7</A>
(<TT>MLexer1.lhs</TT>) has no internal state apart from the input stream,
that is, it provides no additional functionality compared to the
stream-based lexer.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>MLexer</I></TT><TT>&nbsp;(&nbsp;<B>module</B>&nbsp;<I>Terminal</I></TT><TT>,&nbsp;<B>module</B>&nbsp;<I>MLexer</I></TT><TT>&nbsp;)&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Terminal</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Char</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>type</B>&nbsp;<I>CPS</I></TT><TT>&nbsp;a&nbsp;answer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;(a&nbsp;-&gt;&nbsp;answer)&nbsp;-&gt;&nbsp;answer</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>newtype</B>&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;{&nbsp;unLex&nbsp;::&nbsp;forall&nbsp;ans&nbsp;.&nbsp;<I>CPS</I></TT><TT>&nbsp;a&nbsp;(<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;m&nbsp;ans)&nbsp;}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>instance</B>&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;<I>Monad</I></TT><TT>&nbsp;(<I>Lex</I></TT><TT>&nbsp;m)&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;(\&nbsp;cont&nbsp;-&gt;&nbsp;cont&nbsp;a)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;&gt;&gt;=&nbsp;k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;(\&nbsp;cont&nbsp;-&gt;&nbsp;unLex&nbsp;m&nbsp;(\&nbsp;a&nbsp;-&gt;&nbsp;unLex&nbsp;(k&nbsp;a)&nbsp;cont))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;lift&nbsp;(fail&nbsp;s)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lift&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;m&nbsp;a&nbsp;-&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lift&nbsp;m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;(\&nbsp;cont&nbsp;inp&nbsp;-&gt;&nbsp;m&nbsp;&gt;&gt;=&nbsp;\&nbsp;a&nbsp;-&gt;&nbsp;cont&nbsp;a&nbsp;inp)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;run&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;a&nbsp;-&gt;&nbsp;(<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;m&nbsp;a)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;run&nbsp;parser&nbsp;inp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;unLex&nbsp;parser&nbsp;(\&nbsp;a&nbsp;rest&nbsp;-&gt;&nbsp;return&nbsp;a)&nbsp;inp</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;get&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;<I>Terminal</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;get&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;(\&nbsp;cont&nbsp;inp&nbsp;-&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>let</B>&nbsp;lexer&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>EOF</I></TT><TT>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('+'</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>Addop</I></TT><TT>&nbsp;<I>Plus</I></TT><TT>)&nbsp;&nbsp;&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('-'</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>Addop</I></TT><TT>&nbsp;<I>Minus</I></TT><TT>)&nbsp;&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('*'</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>Mulop</I></TT><TT>&nbsp;<I>Times</I></TT><TT>)&nbsp;&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('/'</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>Mulop</I></TT><TT>&nbsp;<I>Divide</I></TT><TT>)&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('='</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>Equal</I></TT><TT>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('('</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>LParen</I></TT><TT>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;(')'</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>RParen</I></TT><TT>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;(c&nbsp;:&nbsp;cs)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;isSpace&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;lexer&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;isAlpha&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<B>let</B>&nbsp;(s,&nbsp;cs')&nbsp;=&nbsp;span&nbsp;isAlphaNum&nbsp;&nbsp;cs&nbsp;<B>in</B>&nbsp;cont&nbsp;(ident&nbsp;&nbsp;&nbsp;&nbsp;(c&nbsp;:&nbsp;s))&nbsp;cs'</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;isDigit&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<B>let</B>&nbsp;(s,&nbsp;cs')&nbsp;=&nbsp;span&nbsp;isDigit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs&nbsp;<B>in</B>&nbsp;cont&nbsp;(numeral&nbsp;&nbsp;(c&nbsp;:&nbsp;s))&nbsp;cs'</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;otherwise&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;lexer&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>in</B>&nbsp;&nbsp;lexer&nbsp;inp)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;<I>Terminal</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;(\&nbsp;cont&nbsp;inp&nbsp;-&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail&nbsp;("\n***&nbsp;syntax&nbsp;error:\n"&nbsp;++&nbsp;context&nbsp;4&nbsp;inp))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;context&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>Int</I></TT><TT>&nbsp;-&gt;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;<I>String</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;context&nbsp;n&nbsp;inp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;unlines&nbsp;(take&nbsp;n&nbsp;(lines&nbsp;inp&nbsp;++&nbsp;["&lt;end&nbsp;of&nbsp;input&gt;"]))
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<DIV CLASS="center">Figure 3.7: <A NAME="fig:mlexer1"></A>A monadic lexer for the <TT><B>let</B></TT> language (<TT>MLexer1.lhs</TT>).</DIV><BR>
<BR>

<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
Note that we use a continuation-based state monad, <TT><I>Lex</I></TT><TT>&nbsp;m</TT>, which
requires local universal quantification (a non-Haskell&nbsp;98 feature).
Actually, <TT><I>Lex</I></TT> is even a <I><FONT COLOR=maroon>monad transformer</FONT></I> so that we can
freely choose a base monad (such as <TT><I>Result</I></TT> or <TT><I>IO</I></TT>). Of course, an
`ordinary' state monad would do, as well. The monadic lexer <TT>get</TT>
incorporates more or less the stream-based lexer. We only changed the
recursive calls to lexer (ie <TT>t&nbsp;:&nbsp;lexer&nbsp;cs</TT>) into invocations of the
continuation (ie <TT>cont&nbsp;t&nbsp;cs</TT>). The error routine <TT>frown</TT> now has type

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;<I>Terminal</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;a&nbsp;,
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
that is, <TT>frown</TT> is no longer passed the remaining input but only the
look-ahead token.<BR>
<BR>
The changes to the grammar are minor: we have to declare an `end of
file' token marked by a star (<TT>Let4.lg</TT>)

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Numeral</I></TT><TT>&nbsp;{<I>Int</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;{<I>String</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Addop</I></TT><TT>&nbsp;{<I>Op</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Mulop</I></TT><TT>&nbsp;{<I>Op</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>KWLet</I></TT><TT>&nbsp;&nbsp;&nbsp;as&nbsp;"let"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>KWIn</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"in"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Equal</I></TT><TT>&nbsp;&nbsp;&nbsp;as&nbsp;"="</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>LParen</I></TT><TT>&nbsp;&nbsp;as&nbsp;"("</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>RParen</I></TT><TT>&nbsp;&nbsp;as&nbsp;")"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;*<I>EOF</I></TT><TT>;
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
and we have to provide a type signature for the generated parser (in
the Haskell section).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;<I>Expr</I></TT><TT>
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The type signature is necessary to avoid an `unresolved top-level
overloading' error (the monomorphism restriction strikes again).<BR>
<BR>
When we generate the Haskell parser we must supply the option <TT>--lexer</TT>
to inform <FONT COLOR=purple>Frown</FONT> that we use a monadic lexer.
<BLOCKQUOTE CLASS="quote">
<TT>frown&nbsp;--lexer&nbsp;Let.g</TT>
</BLOCKQUOTE>
For completeness, here is an interactive session (note that in the
case of error the look-ahead token is <EM>not</EM> displayed).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1)&nbsp;-&nbsp;1"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;7)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1)&nbsp;-&nbsp;1\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&nbsp;("a"&nbsp;:=:&nbsp;<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;7)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1))&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a")&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a"))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;Program&nbsp;error:&nbsp;user&nbsp;error&nbsp;(</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;***&nbsp;syntax&nbsp;error:</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;a&nbsp;*&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&lt;end&nbsp;of&nbsp;input&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;)</TT><TT>
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>

<H3 CLASS="subsection"><A NAME="htoc20">3.3.2</A>&nbsp;&nbsp;Error reporting</H3>
<A NAME="sec:reporting"></A>

The monadic lexer shown in Fig.&nbsp;<A HREF="#fig:mlexer2">3.8</A> (<TT>MLexer2.lhs</TT>)
builds upon the one given in the previous section. The state monad
<TT><I>Lex</I></TT><TT>&nbsp;m</TT> has been extended to keep track of the current line number and
the current line itself. The current line is displayed in case of a
lexical or syntax error. As an aside, note that the column number can
be recreated from the rest of the input and the length of the current
line.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>MLexer</I></TT><TT>&nbsp;(&nbsp;<B>module</B>&nbsp;<I>Terminal</I></TT><TT>,&nbsp;<B>module</B>&nbsp;<I>MLexer</I></TT><TT>&nbsp;)&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Terminal</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Char</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>type</B>&nbsp;<I>CPS</I></TT><TT>&nbsp;a&nbsp;answer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;(a&nbsp;-&gt;&nbsp;answer)&nbsp;-&gt;&nbsp;answer</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>newtype</B>&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;{&nbsp;unLex&nbsp;::&nbsp;forall&nbsp;ans&nbsp;.&nbsp;<I>CPS</I></TT><TT>&nbsp;a&nbsp;(<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Int</I></TT><TT>&nbsp;-&gt;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;m&nbsp;ans)&nbsp;}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>instance</B>&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;<I>Monad</I></TT><TT>&nbsp;(<I>Lex</I></TT><TT>&nbsp;m)&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;(\&nbsp;cont&nbsp;-&gt;&nbsp;cont&nbsp;a)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;&gt;&gt;=&nbsp;k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;(\&nbsp;cont&nbsp;-&gt;&nbsp;unLex&nbsp;m&nbsp;(\&nbsp;a&nbsp;-&gt;&nbsp;unLex&nbsp;(k&nbsp;a)&nbsp;cont))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;lift&nbsp;(fail&nbsp;s)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lift&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;m&nbsp;a&nbsp;-&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lift&nbsp;m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;(\&nbsp;cont&nbsp;inp&nbsp;line&nbsp;cur&nbsp;-&gt;&nbsp;m&nbsp;&gt;&gt;=&nbsp;\&nbsp;a&nbsp;-&gt;&nbsp;cont&nbsp;a&nbsp;inp&nbsp;line&nbsp;cur)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;run&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;a&nbsp;-&gt;&nbsp;(<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;m&nbsp;a)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;run&nbsp;parser&nbsp;inp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;unLex&nbsp;parser&nbsp;(\&nbsp;a&nbsp;rest&nbsp;line&nbsp;cur&nbsp;-&gt;&nbsp;return&nbsp;a)&nbsp;inp&nbsp;1&nbsp;(current&nbsp;inp)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;current&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;<I>String</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;current&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;takeWhile&nbsp;(/=&nbsp;'\n'</TT><TT>)&nbsp;s</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;get&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;<I>Terminal</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;get&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;(\&nbsp;cont&nbsp;inp&nbsp;line&nbsp;cur&nbsp;-&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;<B>let</B>&nbsp;&nbsp;lexer&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;x&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>EOF</I></TT><TT>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[]&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('\n'</TT><TT>&nbsp;:&nbsp;cs)&nbsp;n&nbsp;x&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;lexer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs&nbsp;(n&nbsp;+&nbsp;1)&nbsp;(current&nbsp;cs)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('+'</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;n&nbsp;x&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>Addop</I></TT><TT>&nbsp;<I>Plus</I></TT><TT>)&nbsp;&nbsp;&nbsp;cs&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('-'</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;n&nbsp;x&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>Addop</I></TT><TT>&nbsp;<I>Minus</I></TT><TT>)&nbsp;&nbsp;cs&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('*'</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;n&nbsp;x&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>Mulop</I></TT><TT>&nbsp;<I>Times</I></TT><TT>)&nbsp;&nbsp;cs&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('/'</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;n&nbsp;x&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>Mulop</I></TT><TT>&nbsp;<I>Divide</I></TT><TT>)&nbsp;cs&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('='</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;n&nbsp;x&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>Equal</I></TT><TT>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('('</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;n&nbsp;x&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>LParen</I></TT><TT>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;(')'</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;n&nbsp;x&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>RParen</I></TT><TT>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;(c&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;isSpace&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;lexer&nbsp;cs&nbsp;n&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;isAlpha&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<B>let</B>&nbsp;(s,&nbsp;cs')&nbsp;=&nbsp;span&nbsp;isAlphaNum&nbsp;&nbsp;cs&nbsp;<B>in</B>&nbsp;cont&nbsp;(ident&nbsp;&nbsp;&nbsp;&nbsp;(c&nbsp;:&nbsp;s))&nbsp;cs'&nbsp;n&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;isDigit&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<B>let</B>&nbsp;(s,&nbsp;cs')&nbsp;=&nbsp;span&nbsp;isDigit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs&nbsp;<B>in</B>&nbsp;cont&nbsp;(numeral&nbsp;&nbsp;(c&nbsp;:&nbsp;s))&nbsp;cs'&nbsp;n&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;otherwise&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;fail&nbsp;("\n***&nbsp;lexical&nbsp;error&nbsp;at&nbsp;"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++&nbsp;position&nbsp;cs&nbsp;n&nbsp;x&nbsp;++&nbsp;":\n"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++&nbsp;context&nbsp;4&nbsp;cs&nbsp;x)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;<B>in</B>&nbsp;&nbsp;lexer&nbsp;inp&nbsp;line&nbsp;cur)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;<I>Terminal</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;(\&nbsp;cont&nbsp;inp&nbsp;line&nbsp;cur&nbsp;-&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail&nbsp;("\n***&nbsp;syntax&nbsp;error&nbsp;at&nbsp;"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++&nbsp;position&nbsp;inp&nbsp;line&nbsp;cur&nbsp;++&nbsp;":\n"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++&nbsp;context&nbsp;4&nbsp;inp&nbsp;cur))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;position&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Int</I></TT><TT>&nbsp;-&gt;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;<I>String</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;position&nbsp;inp&nbsp;line&nbsp;cur&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;"(line&nbsp;"&nbsp;&nbsp;++&nbsp;show&nbsp;line&nbsp;++&nbsp;",&nbsp;column&nbsp;"&nbsp;++&nbsp;show&nbsp;col&nbsp;++&nbsp;")"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>where</B>&nbsp;col&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;length&nbsp;cur&nbsp;-&nbsp;length&nbsp;(current&nbsp;inp)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;context&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>Int</I></TT><TT>&nbsp;-&gt;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;<I>String</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;context&nbsp;n&nbsp;inp&nbsp;cur&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;unlines&nbsp;([cur,&nbsp;replicate&nbsp;col'&nbsp;'&nbsp;'</TT><TT>&nbsp;++&nbsp;"^"]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++&nbsp;take&nbsp;n&nbsp;(lines&nbsp;(drop&nbsp;1&nbsp;(dropWhile&nbsp;(/=&nbsp;'\n'</TT><TT>)&nbsp;inp))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++&nbsp;["&lt;end&nbsp;of&nbsp;input&gt;"]))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>where</B>&nbsp;col'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;length&nbsp;cur&nbsp;-&nbsp;length&nbsp;(current&nbsp;inp)&nbsp;-&nbsp;1
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<DIV CLASS="center">Figure 3.8: <A NAME="fig:mlexer2"></A>A monadic lexer for the <TT><B>let</B></TT> language featuring good error reports (<TT>MLexer2.lhs</TT>).</DIV><BR>
<BR>

<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>

The following session shows the new lexer in action.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1)&nbsp;-&nbsp;1"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;7)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1)&nbsp;-&nbsp;1\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&nbsp;("a"&nbsp;:=:&nbsp;<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;7)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1))&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a")&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a"))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;[7&nbsp;+&nbsp;1&nbsp;-&nbsp;1)\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;Program&nbsp;error:&nbsp;user&nbsp;error&nbsp;(</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;***&nbsp;lexical&nbsp;error&nbsp;at&nbsp;(line&nbsp;2,&nbsp;column&nbsp;13):</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;[7&nbsp;+&nbsp;1&nbsp;-&nbsp;1)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;in&nbsp;a&nbsp;*&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&lt;end&nbsp;of&nbsp;input&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;Program&nbsp;error:&nbsp;user&nbsp;error&nbsp;(</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;***&nbsp;syntax&nbsp;error&nbsp;at&nbsp;(line&nbsp;3,&nbsp;column&nbsp;3):</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;in&nbsp;a&nbsp;*&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;^</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&lt;end&nbsp;of&nbsp;input&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;)</TT><TT>
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
In the case of a lexical error the cursor `<TT>^</TT>' points at the
offending character. In the case of a syntax error the cursor points
at the <EM>last</EM> character of the offending token (recall that the
part of the input up to and including this token is the shortest
prefix of the input that cannot be extended to a legal sentence of the
grammar).<BR>
<BR>

<H3 CLASS="subsection"><A NAME="htoc21">3.3.3</A>&nbsp;&nbsp;Expected tokens</H3>
<A NAME="sec:expected"></A>

We can do even better! We can instruct <FONT COLOR=purple>Frown</FONT> to pass a list of
<I><FONT COLOR=maroon>expected</FONT></I> tokens to the error routine <TT>frown</TT> (by supplying
the option <TT>--expected</TT>).
<BLOCKQUOTE CLASS="quote">
<TT>frown&nbsp;--lexer&nbsp;--expected&nbsp;Let.g</TT>
</BLOCKQUOTE>
<FONT COLOR=purple>Frown</FONT> uses the shortcuts given in the terminal declaration for generating
lists of expected tokens. This means, in particular, that a token is
<EM>not</EM> included in such a list if it does not have a shortcut. In
our running example, we want every token to be listed. Therefore, we
add shortcuts for every terminal symbol (<TT>Let6.lg</TT>).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Numeral</I></TT><TT>&nbsp;{<I>Int</I></TT><TT>}&nbsp;&nbsp;&nbsp;as&nbsp;"&lt;numeral&gt;"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;{<I>String</I></TT><TT>}&nbsp;&nbsp;as&nbsp;"&lt;identifier&gt;"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Addop</I></TT><TT>&nbsp;{<I>Op</I></TT><TT>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"+&nbsp;or&nbsp;-"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Mulop</I></TT><TT>&nbsp;{<I>Op</I></TT><TT>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"*&nbsp;or&nbsp;/"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>KWLet</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"let"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>KWIn</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"in"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Equal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"="</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>LParen</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"("</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>RParen</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;")"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;*<I>EOF</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"&lt;end&nbsp;of&nbsp;input&gt;";
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The error routine <TT>frown</TT> now takes an additional argument of type
<TT>[<I>String</I></TT><TT>]</TT> (<TT>MLexer3.lhs</TT>).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;[<I>String</I></TT><TT>]&nbsp;-&gt;&nbsp;<I>Terminal</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;la&nbsp;t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;(\&nbsp;cont&nbsp;inp&nbsp;line&nbsp;cur&nbsp;-&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail&nbsp;("\n***&nbsp;syntax&nbsp;error&nbsp;at&nbsp;"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++&nbsp;position&nbsp;inp&nbsp;line&nbsp;cur&nbsp;++&nbsp;":\n"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++&nbsp;context&nbsp;4&nbsp;inp&nbsp;cur</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++&nbsp;"*&nbsp;expected:&nbsp;"&nbsp;++&nbsp;concat&nbsp;(intersperse&nbsp;",&nbsp;"&nbsp;la)))
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The interactive session listed in Fig.&nbsp;<A HREF="#fig:session">3.9</A> is a bit
longer than usual to illustrate the quality of the error messages.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;[7&nbsp;+&nbsp;1&nbsp;-&nbsp;1)\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;Program&nbsp;error:&nbsp;user&nbsp;error&nbsp;(</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;***&nbsp;lexical&nbsp;error&nbsp;at&nbsp;(line&nbsp;2,&nbsp;column&nbsp;13):</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;[7&nbsp;+&nbsp;1&nbsp;-&nbsp;1)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;in&nbsp;a&nbsp;*&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&lt;end&nbsp;of&nbsp;input&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;Program&nbsp;error:&nbsp;user&nbsp;error&nbsp;(</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;***&nbsp;syntax&nbsp;error&nbsp;at&nbsp;(line&nbsp;3,&nbsp;column&nbsp;3):</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;in&nbsp;a&nbsp;*&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;^</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&lt;end&nbsp;of&nbsp;input&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;*&nbsp;expected:&nbsp;+&nbsp;or&nbsp;-,&nbsp;*&nbsp;or&nbsp;/,&nbsp;))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1)\n&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;Program&nbsp;error:&nbsp;user&nbsp;error&nbsp;(</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;***&nbsp;syntax&nbsp;error&nbsp;at&nbsp;(line&nbsp;3,&nbsp;column&nbsp;2):</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;a&nbsp;*&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;^</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&lt;end&nbsp;of&nbsp;input&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;*&nbsp;expected:&nbsp;+&nbsp;or&nbsp;-,&nbsp;*&nbsp;or&nbsp;/,&nbsp;in)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1)\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;Program&nbsp;error:&nbsp;user&nbsp;error&nbsp;(</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;***&nbsp;syntax&nbsp;error&nbsp;at&nbsp;(line&nbsp;2,&nbsp;column&nbsp;7):</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;in&nbsp;a&nbsp;*&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&lt;end&nbsp;of&nbsp;input&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;*&nbsp;expected:&nbsp;+&nbsp;or&nbsp;-,&nbsp;*&nbsp;or&nbsp;/,&nbsp;&lt;end&nbsp;of&nbsp;input&gt;)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;-&nbsp;1)\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;Program&nbsp;error:&nbsp;user&nbsp;error&nbsp;(</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;***&nbsp;syntax&nbsp;error&nbsp;at&nbsp;(line&nbsp;2,&nbsp;column&nbsp;18):</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;-&nbsp;1)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;in&nbsp;a&nbsp;*&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&lt;end&nbsp;of&nbsp;input&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;*&nbsp;expected:&nbsp;&lt;numeral&gt;,&nbsp;&lt;identifier&gt;,&nbsp;let,&nbsp;()</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1)\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;Program&nbsp;error:&nbsp;user&nbsp;error&nbsp;(</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;***&nbsp;syntax&nbsp;error&nbsp;at&nbsp;(line&nbsp;2,&nbsp;column&nbsp;12):</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;in&nbsp;a&nbsp;*&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&lt;end&nbsp;of&nbsp;input&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;*&nbsp;expected:&nbsp;+&nbsp;or&nbsp;-,&nbsp;*&nbsp;or&nbsp;/,&nbsp;in)</TT><TT>
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<DIV CLASS="center">Figure 3.9: <A NAME="fig:session"></A>A session full of syntax errors.</DIV><BR>
<BR>

<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>

<H3 CLASS="subsection"><A NAME="htoc22">3.3.4</A>&nbsp;&nbsp;Error correction</H3>
<A NAME="sec:errorcorrection"></A>

So far we have content ourselves with reporting syntax errors. To a
limited extent it is also possible to <I><FONT COLOR=maroon>correct</FONT></I> errors.
Consider the last rule of the following grammar (<TT>Let7.lg</TT>).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;{<I>Expr</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;{<I>Const</I></TT><TT>&nbsp;n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;<I>Numeral</I></TT><TT>&nbsp;{n};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Var</I></TT><TT>&nbsp;s}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;{s};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Bin</I></TT><TT>&nbsp;e1&nbsp;op&nbsp;e2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;expr&nbsp;{e1},&nbsp;<I>Addop</I></TT><TT>&nbsp;{op},&nbsp;expr&nbsp;{e2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Bin</I></TT><TT>&nbsp;e1&nbsp;op&nbsp;e2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;expr&nbsp;{e1},&nbsp;<I>Mulop</I></TT><TT>&nbsp;{op},&nbsp;expr&nbsp;{e2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Let</I></TT><TT>&nbsp;d&nbsp;e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"let",&nbsp;decl&nbsp;{d},&nbsp;"in",&nbsp;expr&nbsp;{e};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"(",&nbsp;expr&nbsp;{e},&nbsp;")";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"(",&nbsp;expr&nbsp;{e},&nbsp;insert&nbsp;")";
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The symbol <TT>insert&nbsp;")"</TT> instructs <FONT COLOR=purple>Frown</FONT> to automatically insert a
<TT>")"</TT> token <EM>if parsing would otherwise fail</EM>. The special symbol
<TT>insert&nbsp;")"</TT> can be seen as being defined by the &#1108;-production
<TT>insert&nbsp;")"&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;;</TT>. The difference to an `ordinary'
user-defined &#1108;-production is that the rule is only applied if
every other action would fail.<BR>
<BR>
The following session shows the error correction in action.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1)&nbsp;-&nbsp;1"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;7)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1)&nbsp;-&nbsp;1\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&nbsp;("a"&nbsp;:=:&nbsp;<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;7)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1))&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a")&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a"))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&nbsp;("a"&nbsp;:=:&nbsp;<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;7)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)))&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a")&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a"))
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
In the last query the missing parenthesis `)' is inserted just
before the keyword `<TT><B>in</B></TT>'. This may or may not what the user intended!<BR>
<BR>
It is generally a good idea to notify the user if a token is inserted.
This is relatively easy to accomplish using monadic actions
(<TT>Let8.lg</TT>). The parsing monad is now <TT><I>Lex</I></TT><TT>&nbsp;<I>IO</I></TT>; the monad transformer
<TT><I>Lex</I></TT> proves its worth.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT><TT>
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;{<I>Expr</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;{<I>Const</I></TT><TT>&nbsp;n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;<I>Numeral</I></TT><TT>&nbsp;{n};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Var</I></TT><TT>&nbsp;s}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;{s};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Bin</I></TT><TT>&nbsp;e1&nbsp;op&nbsp;e2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;expr&nbsp;{e1},&nbsp;<I>Addop</I></TT><TT>&nbsp;{op},&nbsp;expr&nbsp;{e2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Bin</I></TT><TT>&nbsp;e1&nbsp;op&nbsp;e2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;expr&nbsp;{e1},&nbsp;<I>Mulop</I></TT><TT>&nbsp;{op},&nbsp;expr&nbsp;{e2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Let</I></TT><TT>&nbsp;d&nbsp;e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;"let",&nbsp;decl&nbsp;{d},&nbsp;"in",&nbsp;expr&nbsp;{e};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;"(",&nbsp;expr&nbsp;{e},&nbsp;close&nbsp;{_};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;close&nbsp;&nbsp;{()};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;close&nbsp;&nbsp;{()}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;")";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{%&nbsp;insert&nbsp;")"}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;insert&nbsp;")";
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;insert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;<I>IO</I></TT><TT>&nbsp;()</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;insert&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;lift&nbsp;(putStrLn&nbsp;("Warning:&nbsp;"&nbsp;++&nbsp;s&nbsp;++&nbsp;"&nbsp;inserted"))
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Let's repeat the last query of the previous session.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;Warning:&nbsp;)&nbsp;inserted</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&nbsp;("a"&nbsp;:=:&nbsp;<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;7)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)))&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a")&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a"))
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The reader is invited to extend the code so that the current source
location is additionally printed (informing the user <EM>where</EM> the
token has been inserted).<BR>
<BR>
<A NAME="toc8"></A>
<H2 CLASS="section"><A NAME="htoc23">3.4</A>&nbsp;&nbsp;Advanced features</H2>


<H3 CLASS="subsection"><A NAME="htoc24">3.4.1</A>&nbsp;&nbsp;Rule schemes</H3>

When we define grammars we often find ourselves repeatedly writing
similar rules. A common pattern is the <I><FONT COLOR=maroon>repetition</FONT></I> of
symbols. As an example, the following rules define a repetition of <TT>t</TT>
symbols.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;ts,&nbsp;t;
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
As an aside, note that the second rule is intentionally
<I><FONT COLOR=maroon>left-recursive</FONT></I>. LR parsers prefer left to right
recursion: the rules above use constant stack space whereas the
right-recursive variant requires space linear in the length of the
input.<BR>
<BR>
Now, <FONT COLOR=purple>Frown</FONT> allows to capture recurring patterns using so-called
<I><FONT COLOR=maroon>rule schemes</FONT></I>. Here is the scheme for a repetition of
symbols (of arity <TT>0</TT>).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;many&nbsp;x,&nbsp;x;
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The first line contains <TT>many</TT>'s type signature: it simply says that
neither <TT>many</TT> nor <TT>many</TT>'s argument <TT>x</TT> possess attributes. Given
this scheme we can simply write <TT>many&nbsp;t</TT> for a repetition of <TT>t</TT>
symbols.<BR>
<BR>
The rule for repetition becomes more interesting if the argument
possesses an attribute (is of arity&nbsp;<TT>1</TT>). In this case, <TT>many</TT>
returns a list of semantic values.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many&nbsp;x&nbsp;{[a]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x&nbsp;{a};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many&nbsp;x&nbsp;{[]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many&nbsp;x&nbsp;{as&nbsp;++&nbsp;[a]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;many&nbsp;as&nbsp;{as};&nbsp;x&nbsp;{a};
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
(The use of list concatenation `<TT>++</TT>' in the second rule incurs a
runtime penalty which we will cure later.) The first line contains
again the type signature, which we may read as a conditional clause:
if <TT>x</TT> has one attribute of type <TT>a</TT>, then <TT>many&nbsp;x</TT> has one attribute
of type <TT>[a]</TT>. This schemes comes in handy if we extend our little
expression language by applications and abstractions (we assume that
the abstract syntax has been extended suitably; <TT>aexpr</TT> denotes atomic
expressions).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;{<I>App</I></TT><TT>&nbsp;e&nbsp;es}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;aexpr&nbsp;{e},&nbsp;many&nbsp;aexpr&nbsp;{es};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;{<I>Abs</I></TT><TT>&nbsp;(i&nbsp;:&nbsp;is)&nbsp;e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;"\\",&nbsp;<I>Ident</I></TT><TT>&nbsp;{i},&nbsp;many&nbsp;(<I>Ident</I></TT><TT>&nbsp;{})&nbsp;{is},&nbsp;".",&nbsp;expr&nbsp;{e};
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Note that if we pass terminal symbols as arguments to rule schemes
they must be written with (empty) curly braces&mdash;<FONT COLOR=purple>Frown</FONT> can only
identify terminal symbols, ie patterns, if they have exactly the same
syntactic form as in the terminal declaration. Think of `<TT>{}</TT>' as a
placeholder.<BR>
<BR>
In the above definition of <TT>many</TT> we have used list concatenation to
append an element to a list. The following improved definition does
away with this linear-time operation employing Hughes' efficient
sequence type [<A HREF="Manual007.html#Hug86Nov"><CITE>3</CITE></A>].

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many&nbsp;x&nbsp;&nbsp;{[a]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x&nbsp;{a};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many&nbsp;x&nbsp;&nbsp;{s&nbsp;[]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;many'&nbsp;x&nbsp;{s};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many'&nbsp;x&nbsp;&nbsp;{[a]&nbsp;-&gt;&nbsp;[a]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x&nbsp;{a};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many'&nbsp;x&nbsp;&nbsp;{\&nbsp;as&nbsp;-&gt;&nbsp;as}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\&nbsp;as&nbsp;-&gt;&nbsp;s&nbsp;(a&nbsp;:&nbsp;as)}&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;many'&nbsp;x&nbsp;{s},&nbsp;x&nbsp;{a};
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
These schemata are predefined in <FONT COLOR=purple>Frown</FONT>. There is a caveat, however:
the singleton production <TT>many&nbsp;x&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;many'&nbsp;x</TT> may
introduce a shift/reduce conflict, see Sec.&nbsp;<A HREF="Manual005.html#sec:conflicts">4.3</A>.<BR>
<BR>
Actually, both the <TT>many</TT> scheme with no attributes and the scheme
above with one attribute are predefined. In general, it is possible to
use the same name for schemes and nonterminals of different arity. The
only restriction is that the arity of the scheme must determine the
arity of its arguments.<BR>
<BR>
Another useful variation of <TT>many</TT> is <TT>sepBy&nbsp;x&nbsp;sep</TT> which denotes a
list of <TT>x</TT> symbols separated by <TT>sep</TT> symbols (<TT>sepBy</TT> and <TT>sepBy1</TT>
are predefined, as well).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;sepBy&nbsp;x&nbsp;sep&nbsp;&nbsp;{[a]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x&nbsp;{a},&nbsp;sep;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;sepBy&nbsp;x&nbsp;sep&nbsp;&nbsp;{[]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{as}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;sepBy1&nbsp;x&nbsp;sep&nbsp;{as};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;sepBy1&nbsp;x&nbsp;sep&nbsp;&nbsp;{[a]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x&nbsp;{a},&nbsp;sep;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;sepBy1&nbsp;x&nbsp;sep&nbsp;&nbsp;{[a]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;x&nbsp;{a};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{as&nbsp;++&nbsp;[a]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;sepBy1&nbsp;x&nbsp;sep&nbsp;{as},&nbsp;sep,&nbsp;x&nbsp;{a};
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
This scheme is useful for adding tuples to our expression language.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;{<I>Tuple</I></TT><TT>&nbsp;es}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;"(",&nbsp;sepBy&nbsp;expr&nbsp;","&nbsp;{es},&nbsp;")";
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
For a complete list of predefined schemes see
Sec.&nbsp;<A HREF="Manual006.html#sec:stdenv">5.3</A>.<BR>
<BR>

<H3 CLASS="subsection"><A NAME="htoc25">3.4.2</A>&nbsp;&nbsp;A second look at terminal symbols</H3>
<A NAME="sec:terminal2"></A>

The terminal symbols of a grammar are given by Haskell
<I><FONT COLOR=maroon>patterns</FONT></I>. Up to now we have seen only simple
patterns. Patterns, however, may also be nested or even
overlapping. In the latter case, one should be careful to list
specific patterns before general ones in a <TT><I>Terminal</I></TT> declaration
(<FONT COLOR=purple>Frown</FONT> preserves the relative ordering of patterns when generating
<TT><B>case</B></TT> expressions). Here is a simple example.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;"if"&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"if"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;"then"&nbsp;&nbsp;as&nbsp;"then"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;"else"&nbsp;&nbsp;as&nbsp;"else"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;{<I>String</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;ldots
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Note that keywords are declared just by listing them before the
general pattern for identifiers.<BR>
<BR>
Alternatively, terminal symbols can be specifed using so-called
<I><FONT COLOR=maroon>guards</FONT></I>, Boolean functions of type <TT><I>Terminal</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Bool</I></TT>.
Guards are most useful for defining character classes as in the
following example.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;guard&nbsp;{&nbsp;isAlpha&nbsp;}&nbsp;as&nbsp;"alpha"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;ldots
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
A guard is introduced by the keyword <TT>guard</TT>, followed by its Haskell
definition, followed by the mandatory shortcut. The shortcut can then
be used as a terminal symbol <EM>of arity&nbsp;<TT>1</TT></EM>: its attribute of
type <TT><I>Terminal</I></TT> is the very input symbol that matched the guard.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;ident&nbsp;{<I>String</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;ident&nbsp;{c&nbsp;:&nbsp;cs}&nbsp;&nbsp;:&nbsp;&nbsp;"alpha"&nbsp;{c},&nbsp;many&nbsp;"alpha"&nbsp;{cs};
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
Using guards one can quite easily define character-based grammars that
include lexical syntax (that is, whose parsers combine lexing and
parsing). Fig.&nbsp;<A HREF="#fig:varcalc">3.10</A> lists a variant of the desktop
calculator that works without a separate lexer.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Calc</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Result</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Char</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>type</B>&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Char</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;%{</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;guard&nbsp;{isDigit}&nbsp;&nbsp;as&nbsp;"digit"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;'+'</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;'*'</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;'('</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;')'</TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Nonterminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;expr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Integer</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;term&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Integer</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;factor&nbsp;&nbsp;&nbsp;{<I>Integer</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;numeral&nbsp;&nbsp;{<I>Integer</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{v1&nbsp;+&nbsp;v2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;expr&nbsp;{v1},&nbsp;&nbsp;'+'</TT><TT>,&nbsp;&nbsp;term&nbsp;{v2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;term&nbsp;{e};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;term&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{v1&nbsp;*&nbsp;v2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;term&nbsp;{v1},&nbsp;&nbsp;'*'</TT><TT>,&nbsp;&nbsp;factor&nbsp;{v2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;factor&nbsp;{e};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;factor&nbsp;&nbsp;&nbsp;{n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;numeral&nbsp;{n};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;'('</TT><TT>,&nbsp;expr&nbsp;{e},&nbsp;')'</TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;numeral&nbsp;&nbsp;{encode&nbsp;c}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;"digit"&nbsp;{c};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{n&nbsp;*&nbsp;10&nbsp;+&nbsp;encode&nbsp;c}&nbsp;&nbsp;|&nbsp;&nbsp;numeral&nbsp;{n},&nbsp;"digit"&nbsp;{c};&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;}%</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;encode&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;toInteger&nbsp;(fromEnum&nbsp;&nbsp;c&nbsp;-&nbsp;fromEnum&nbsp;'0'</TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;fail&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<DIV CLASS="center">Figure 3.10: <A NAME="fig:varcalc"></A>A variant of the desktop calculator that includes
lexical syntax (<TT>VarCalc.lhs</TT>).</DIV><BR>
<BR>

<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
Note that the type <TT><I>Terminal</I></TT> must be defined in the Haskell section.
The reader may wish to extend the grammar so that two tokens can be
separated by white space.<BR>
<BR>

<H3 CLASS="subsection"><A NAME="htoc26">3.4.3</A>&nbsp;&nbsp;Look-ahead</H3>
<A NAME="sec:look-ahead"></A>

&lang;<B>To do:</B>&nbsp;type grammar.&rang;<BR>
<BR>

<H3 CLASS="subsection"><A NAME="htoc27">3.4.4</A>&nbsp;&nbsp;Debugging and tracing</H3>
<A NAME="sec:tracing"></A>

&lang;<B>To do:</B>&nbsp;<TT>--prefix</TT> und <TT>--suffix</TT>.&rang;<BR>
<BR>
&lang;<B>To do:</B>&nbsp;<TT>--debug</TT> und <TT>--pagewidth</TT>.&rang;<BR>
<BR>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Paren</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;%{</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;'('</TT><TT>&nbsp;|&nbsp;')'</TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;{<I>IO</I></TT><TT>&nbsp;()};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;{reduce&nbsp;"p&nbsp;:&nbsp;;"}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;{<B>do</B>&nbsp;t1;&nbsp;shift&nbsp;'('</TT><TT>;&nbsp;t2;&nbsp;shift&nbsp;')'</TT><TT>;&nbsp;reduce&nbsp;"p&nbsp;:&nbsp;p,&nbsp;'(',&nbsp;p,&nbsp;')';"}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;paren&nbsp;{t1},&nbsp;'('</TT><TT>,&nbsp;paren&nbsp;{t2},&nbsp;')'</TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;}%</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;fail&nbsp;"***&nbsp;syntax&nbsp;error"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;shift&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>Char</I></TT><TT>&nbsp;-&gt;&nbsp;<I>IO</I></TT><TT>&nbsp;()</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;shift&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;putStrLn&nbsp;("shift&nbsp;"&nbsp;++&nbsp;show&nbsp;c)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;reduce&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;<I>IO</I></TT><TT>&nbsp;()</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;reduce&nbsp;p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;putStrLn&nbsp;("reduce&nbsp;by&nbsp;"&nbsp;++&nbsp;p)
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>

<H3 CLASS="subsection"><A NAME="htoc28">3.4.5</A>&nbsp;&nbsp;Output formats and optimizations</H3>
<A NAME="sec:optimizations"></A>

&lang;<B>To do:</B>&nbsp;optimizations (<TT>--optimize</TT>).&rang;<BR>
<BR>
&lang;<B>To do:</B>&nbsp;which format benefits from GHC extensions (<TT>--ghc</TT>)?&rang;<BR>
<BR>
&lang;<B>To do:</B>&nbsp;<TT>NOINLINE</TT> pragmas (<TT>--noinline</TT>).&rang;<BR>
<BR>
&lang;<B>To do:</B>&nbsp;<TT>--signature</TT>.&rang;<BR>
<BR>
<HR WIDTH="50%" SIZE=1><DL CLASS="list"><DT CLASS="dt-list"><A NAME="note2" HREF="#text2"><FONT SIZE=5>1</FONT></A><DD CLASS="dd-list">In fact, we can use the same notation, the
 so-called <I><FONT COLOR=maroon><TT><B>do</B></TT>-notation</FONT></I>, for different monads (cf
 Haskell Report 3.14).
<DT CLASS="dt-list"><A NAME="note3" HREF="#text3"><FONT SIZE=5>2</FONT></A><DD CLASS="dd-list">The source files of the examples are
located in the directory <TT>Manual/Examples</TT>.
<DT CLASS="dt-list"><A NAME="note4" HREF="#text4"><FONT SIZE=5>3</FONT></A><DD CLASS="dd-list">Actually, the file is
 generated using <TT>frown&nbsp;--suffix&nbsp;Paren.g</TT>, see
 Sec.&nbsp;<A HREF="Manual006.html#sec:options">5.5</A>.
<DT CLASS="dt-list"><A NAME="note5" HREF="#text5"><FONT SIZE=5>4</FONT></A><DD CLASS="dd-list">There is, however, a small cost involved: for each start
 symbol <TT>s</TT> <FONT COLOR=purple>Frown</FONT> silently introduces a new symbol <TT>s'</TT> and a new
 rule <TT>s'&nbsp;:&nbsp;s,&nbsp;<I>EOF</I></TT>. This increases the size of the automaton by a
 few states.
</DL>
<HR>
<A HREF="Manual003.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="Manual005.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
