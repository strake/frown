<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>

<HEAD>


<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.08">
<STYLE type="text/css">
.toc{list-style:none;}
.title{margin:auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
.part{margin:auto;text-align:center}
</STYLE>
</HEAD>

<BODY >
<!--HEVEA command line is: hevea -fix Manual.tex -->
<!--HTMLHEAD-->
<!--ENDHTML-->
<!--PREFIX <ARG ></ARG>-->
<!--CUT DEF chapter 1 -->

<BR>
<TABLE CLASS="title">
<TR><TD></TD>
</TR></TABLE>
<BLOCKQUOTE CLASS="quote"><B>Abstract: </B>
<FONT COLOR=purple>Frown</FONT> is an LALR(<I>k</I>) parser generator for Haskell&nbsp;98 written in
Haskell&nbsp;98.<BR>
<BR>
<BR>

Its salient features are:
<UL CLASS="itemize"><LI CLASS="li-itemize">
The generated parsers are time and space efficient. On the downside,
 the parsers are quite large.<BR>
<BR>
<LI CLASS="li-itemize"><FONT COLOR=purple>Frown</FONT> generates four different types of parsers. As a common
 characteristic, the parsers are <EM>genuinely functional</EM> (ie
 `table-free'); the states of the underlying LR automaton are encoded
 as mutually recursive functions. Three output formats use a typed
 stack representation, one format due to Ross Paterson
 (<TT>code=stackless</TT>) works even without a stack.<BR>
<BR>
<LI CLASS="li-itemize">Encoding states as functions means that each state can be
 treated individually as opposed to a table driven-approach, which
 necessitates a uniform treatment of states. For instance, look-ahead
 is only used when necessary to resolve conflicts.<BR>
<BR>
<LI CLASS="li-itemize"><FONT COLOR=purple>Frown</FONT> comes with debugging and tracing facilities; the standard
 output format due to Doaitse Swierstra (<TT>code=standard</TT>) may be
 useful for teaching LR parsing.<BR>
<BR>
<LI CLASS="li-itemize">Common grammatical patterns such as repetition of symbols can
 be captured using <EM>rule schemata</EM>. There are several predefined
 rule schemata.<BR>
<BR>
<LI CLASS="li-itemize">Terminal symbols are arbitrary variable-free Haskell patterns
 or guards. Both terminal and nonterminal symbols may have an
 arbitrary number of synthesized attributes.<BR>
<BR>
<LI CLASS="li-itemize"><FONT COLOR=purple>Frown</FONT> comes with extensive documentation; several example
 grammars are included.
</UL>
Furthermore, <FONT COLOR=purple>Frown</FONT> supports the use of monadic lexers, monadic
semantic actions, precedences and associativity, the generation of
backtracking parsers, multiple start symbols, error reporting and a
weak form of error correction.
</BLOCKQUOTE>
<!--TOC chapter Contents-->

<H1 CLASS="chapter">Contents</H1><!--SEC END -->

<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc1">Chapter&nbsp;1&nbsp;&nbsp;Introduction</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc2">1.1&nbsp;&nbsp;Obtaining and installing <FONT COLOR=purple>Frown</FONT></A>
<LI CLASS="li-toc"><A HREF="#htoc3">1.2&nbsp;&nbsp;Reporting bugs</A>
<LI CLASS="li-toc"><A HREF="#htoc4">1.3&nbsp;&nbsp;License</A>
<LI CLASS="li-toc"><A HREF="#htoc5">1.4&nbsp;&nbsp;Credits</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc6">Chapter&nbsp;2&nbsp;&nbsp;Quick start</A>
<LI CLASS="li-toc"><A HREF="#htoc7">Chapter&nbsp;3&nbsp;&nbsp;Tour de <FONT COLOR=purple>Frown</FONT></A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc8">3.1&nbsp;&nbsp;Preliminaries: monads</A>
<LI CLASS="li-toc"><A HREF="#htoc9">3.2&nbsp;&nbsp;Basic features</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc10">3.2.1&nbsp;&nbsp;Pure grammars</A>
<LI CLASS="li-toc"><A HREF="#htoc11">3.2.2&nbsp;&nbsp;Attributes</A>
<LI CLASS="li-toc"><A HREF="#htoc12">3.2.3&nbsp;&nbsp;Interfacing with a lexer</A>
<LI CLASS="li-toc"><A HREF="#htoc13">3.2.4&nbsp;&nbsp;Monadic actions</A>
<LI CLASS="li-toc"><A HREF="#htoc14">3.2.5&nbsp;&nbsp;Backtracking parsers</A>
<LI CLASS="li-toc"><A HREF="#htoc15">3.2.6&nbsp;&nbsp;Precedences and associativity</A>
<LI CLASS="li-toc"><A HREF="#htoc16">3.2.7&nbsp;&nbsp;Multiple start symbols</A>
<LI CLASS="li-toc"><A HREF="#htoc17">3.2.8&nbsp;&nbsp;Monadic attributes</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc18">3.3&nbsp;&nbsp;Error reporting and correction</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc19">3.3.1&nbsp;&nbsp;Monadic lexers</A>
<LI CLASS="li-toc"><A HREF="#htoc20">3.3.2&nbsp;&nbsp;Error reporting</A>
<LI CLASS="li-toc"><A HREF="#htoc21">3.3.3&nbsp;&nbsp;Expected tokens</A>
<LI CLASS="li-toc"><A HREF="#htoc22">3.3.4&nbsp;&nbsp;Error correction</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc23">3.4&nbsp;&nbsp;Advanced features</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc24">3.4.1&nbsp;&nbsp;Rule schemes</A>
<LI CLASS="li-toc"><A HREF="#htoc25">3.4.2&nbsp;&nbsp;A second look at terminal symbols</A>
<LI CLASS="li-toc"><A HREF="#htoc26">3.4.3&nbsp;&nbsp;Look-ahead</A>
<LI CLASS="li-toc"><A HREF="#htoc27">3.4.4&nbsp;&nbsp;Debugging and tracing</A>
<LI CLASS="li-toc"><A HREF="#htoc28">3.4.5&nbsp;&nbsp;Output formats and optimizations</A>
</UL>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc29">Chapter&nbsp;4&nbsp;&nbsp;Tips and tricks</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc30">4.1&nbsp;&nbsp;Irrefutable patterns</A>
<LI CLASS="li-toc"><A HREF="#htoc31">4.2&nbsp;&nbsp;Inherited attributes</A>
<LI CLASS="li-toc"><A HREF="#htoc32">4.3&nbsp;&nbsp;Dealing with conflicts</A>
<LI CLASS="li-toc"><A HREF="#htoc33">4.4&nbsp;&nbsp;Multiple attributes</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc34">Chapter&nbsp;5&nbsp;&nbsp;Reference manual</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc35">5.1&nbsp;&nbsp;Lexical syntax of <FONT COLOR=purple>Frown</FONT></A>
<LI CLASS="li-toc"><A HREF="#htoc36">5.2&nbsp;&nbsp;Syntax of <FONT COLOR=purple>Frown</FONT></A>
<LI CLASS="li-toc"><A HREF="#htoc37">5.3&nbsp;&nbsp;Predefined schemes</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc38">5.3.1&nbsp;&nbsp;Optional elements</A>
<LI CLASS="li-toc"><A HREF="#htoc39">5.3.2&nbsp;&nbsp;Repetition of elements</A>
<LI CLASS="li-toc"><A HREF="#htoc40">5.3.3&nbsp;&nbsp;Repetition of elements separated by a second element</A>
<LI CLASS="li-toc"><A HREF="#htoc41">5.3.4&nbsp;&nbsp;Repetition of possibly empty elements separated by a second element</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc42">5.4&nbsp;&nbsp;Output formats</A>
<LI CLASS="li-toc"><A HREF="#htoc43">5.5&nbsp;&nbsp;Invocation and options</A>
</UL>
</UL>

<!--TOC chapter Introduction-->

<H1 CLASS="chapter"><A NAME="htoc1">Chapter&nbsp;1</A>&nbsp;&nbsp;Introduction</H1><!--SEC END -->

<A NAME="sec:introduction"></A>

<FONT COLOR=purple>Frown</FONT> is an LALR(<I>k</I>) parser generator for Haskell&nbsp;98 written in
Haskell&nbsp;98.<BR>
<BR>
The work on <FONT COLOR=purple>Frown</FONT> started as an experiment in generating genuinely
functional LR parsers. The first version was written within three
days&mdash;yes, Haskell is a wonderful language for rapid prototyping.
Since then <FONT COLOR=purple>Frown</FONT> has gone through several cycles of reorganization
and rewriting. It also grew considerably: dozens of features were
added, examples were conceived and tested, and this manual was
written. In the end, <FONT COLOR=purple>Frown</FONT> has become a useable tool. I hope you
will find it useful, too.<BR>
<BR>
<!--TOC section Obtaining and installing <FONT COLOR=purple>Frown</FONT>-->

<H2 CLASS="section"><A NAME="htoc2">1.1</A>&nbsp;&nbsp;Obtaining and installing <FONT COLOR=purple>Frown</FONT></H2><!--SEC END -->

<A NAME="sec:install"></A>

<!--TOC paragraph Obtaining <FONT COLOR=purple>Frown</FONT>-->

<H5 CLASS="paragraph">Obtaining <FONT COLOR=purple>Frown</FONT></H5><!--SEC END -->

The parser generator is available from
<BLOCKQUOTE CLASS="quote">
<TT>http://www.informatik.uni-bonn.de/~ralf/frown</TT>.
</BLOCKQUOTE>
The bundle includes the sources and the complete documentation (dvi,
ps, PDF, and HTML).<BR>
<BR>
<!--TOC paragraph Requirements-->

<H5 CLASS="paragraph">Requirements</H5><!--SEC END -->

You should be able to build <FONT COLOR=purple>Frown</FONT> with every Haskell&nbsp;98-compliant
compiler. You have to use a not too ancient compiler as there have
been some changes to the Haskell language in Sep.&nbsp;2001 (GHC 5.02 and
later versions will do).<BR>
<BR>
The Haskell interpreter Hugs&nbsp;98 is needed for running the testsuite.<BR>
<BR>
Various tools are required to generate the documentation from scratch:
<TT>lhs2TeX</TT>, L<sup>A</sup>T<sub>E</sub>X, functional , H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A and H<FONT SIZE=2><sup>A</sup></FONT>C<FONT SIZE=2><sup>H</sup></FONT>A. Note, however, that
the bundle already includes the complete documentation.<BR>
<BR>
<!--TOC paragraph Installation-->

<H5 CLASS="paragraph">Installation</H5><!--SEC END -->

Unzip and untar the bundle. This creates a directory called <TT>Frown</TT>.
Enter this directory.
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&nbsp;ralf&gt;&nbsp;tar&nbsp;xzf&nbsp;frown.tar.gz</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&nbsp;ralf&gt;&nbsp;cd&nbsp;Frown
</TT></TD>
</TR></TABLE>
The documentation resides in the directory <TT>Manual</TT>; example grammars
can be found in <TT>Examples</TT> and <TT>Manual/Examples</TT> (the files ending in
<TT>.g</TT> and <TT>.lg</TT>).<BR>
<BR>
You can install <FONT COLOR=purple>Frown</FONT> using either traditional makefiles or Cabal.<BR>
<BR>
<!--TOC paragraph Using makefiles-->

<H5 CLASS="paragraph">Using makefiles</H5><!--SEC END -->

Optionally, edit the <TT>Makefile</TT> to specify destinations for the binary
and the documentation (this information is only used by <TT>make&nbsp;install</TT>). Now, you can trigger
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&nbsp;ralf/Frown&gt;&nbsp;make
</TT></TD>
</TR></TABLE>
which compiles <FONT COLOR=purple>Frown</FONT> generating an executable called <TT>frown</TT> (to use
<FONT COLOR=purple>Frown</FONT> you only need this executable). Optionally, continue with
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&nbsp;ralf/Frown&gt;&nbsp;make&nbsp;install
</TT></TD>
</TR></TABLE>
to install the executable and the documentation.<BR>
<BR>
For reference, here is a list of possible targets:
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description">
<B><TT>make</TT></B><DD CLASS="dd-description"><BR>
Compiles <FONT COLOR=purple>Frown</FONT> generating an executable called <TT>frown</TT> (to use <FONT COLOR=purple>Frown</FONT> 
 you only need this executable).<BR>
<BR>
<DT CLASS="dt-description"><B><TT>make&nbsp;install</TT></B><DD CLASS="dd-description"><BR>
Compiles <FONT COLOR=purple>Frown</FONT> and installs the executable and the documentation.<BR>
<BR>
<DT CLASS="dt-description"><B><TT>make&nbsp;test</TT></B><DD CLASS="dd-description"><BR>
Runs the testsuite.<SUP><A NAME="text1" HREF="#note1">1</A></SUP><BR>
<BR>
<DT CLASS="dt-description"><B><TT>make&nbsp;man</TT></B><DD CLASS="dd-description"><BR>
Generates the documentation in various formats (dvi, ps, PDF, and
 HTML).<BR>
<BR>
<DT CLASS="dt-description"><B><TT>make&nbsp;clean</TT></B><DD CLASS="dd-description"><BR>
Removes some temporary files.<BR>
<BR>
<DT CLASS="dt-description"><B><TT>make&nbsp;distclean</TT></B><DD CLASS="dd-description"><BR>
Removes all files except the ones that are included in the distribution.
</DL>
<!--TOC paragraph Using Cabal-->

<H5 CLASS="paragraph">Using Cabal</H5><!--SEC END -->

Alternatively, you can build <FONT COLOR=purple>Frown</FONT> using Cabal (version 1.1.3 or
later), Haskell's Common Architecture for Building Applications and
Libraries.<BR>
<BR>
For a global install, type:
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&nbsp;ralf/Frown&gt;&nbsp;runhaskell&nbsp;Setup.hs&nbsp;configure&nbsp;--ghc</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&nbsp;ralf/Frown&gt;&nbsp;runhaskell&nbsp;Setup.hs&nbsp;build</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&nbsp;ralf/Frown&gt;&nbsp;runhaskell&nbsp;Setup.hs&nbsp;install
</TT></TD>
</TR></TABLE>
If you want to install <FONT COLOR=purple>Frown</FONT> locally, use (you may wish to replace
<TT>$HOME</TT> by a directory of your choice):
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&nbsp;ralf/Frown&gt;&nbsp;runhaskell&nbsp;Setup.hs&nbsp;configure&nbsp;--ghc&nbsp;--prefix=$HOME</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&nbsp;ralf/Frown&gt;&nbsp;runhaskell&nbsp;Setup.hs&nbsp;build</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&nbsp;ralf/Frown&gt;&nbsp;runhaskell&nbsp;Setup.hs&nbsp;install&nbsp;--user
</TT></TD>
</TR></TABLE><BR>
<!--TOC paragraph Usage-->

<H5 CLASS="paragraph">Usage</H5><!--SEC END -->

The call
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&nbsp;ralf/Frown&gt;&nbsp;frown&nbsp;-h
</TT></TD>
</TR></TABLE>
displays the various options. For more information consult this
manual.<BR>
<BR>
<!--TOC section Reporting bugs-->

<H2 CLASS="section"><A NAME="htoc3">1.2</A>&nbsp;&nbsp;Reporting bugs</H2><!--SEC END -->


Bug reports should be send to Ralf Hinze (<TT>ralf@cs.uni-bonn.de</TT>).
The report should include all information necessary to reproduce the
bug: the compiler used to compile <FONT COLOR=purple>Frown</FONT>, the grammar source file (and
possibly auxiliary Haskell source files), and the command-line
invocation of <FONT COLOR=purple>Frown</FONT>.<BR>
<BR>
Suggestions for improvements or request for features should also be
sent to the above address.<BR>
<BR>
<!--TOC section License-->

<H2 CLASS="section"><A NAME="htoc4">1.3</A>&nbsp;&nbsp;License</H2><!--SEC END -->


<FONT COLOR=purple>Frown</FONT> is distributed under the GNU general public licence
(version&nbsp;2).
<PRE CLASS="verbatim">
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%   Frown --- An LALR(k) parser generator for Haskell 98                      %
%   Copyright (C) 2001-2005 Ralf Hinze                                        %
%                                                                             %
%   This program is free software; you can redistribute it and/or modify      %
%   it under the terms of the GNU General Public License (version 2) as       %
%   published by the Free Software Foundation.                                %
%                                                                             %
%   This program is distributed in the hope that it will be useful,           %
%   but WITHOUT ANY WARRANTY; without even the implied warranty of            %
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             %
%   GNU General Public License for more details.                              %
%                                                                             %
%   You should have received a copy of the GNU General Public License         %
%   along with this program; see the file COPYING.  If not, write to          %
%   the Free Software Foundation, Inc., 59 Temple Place - Suite 330,          %
%   Boston, MA 02111-1307, USA.                                               %
%                                                                             %
%   Contact information                                                       %
%   Email:      Ralf Hinze &lt;ralf@cs.uni-bonn.de&gt;                              %
%   Homepage:   http://www.informatik.uni-bonn.de/~ralf/                      %
%   Paper mail: Dr. Ralf Hinze                                                %
%               Institut für Informatik III                                   %
%               Universität Bonn                                              %
%               Römerstraße 164                                               %
%               53117 Bonn, Germany                                           %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
</PRE>
<!--TOC section Credits-->

<H2 CLASS="section"><A NAME="htoc5">1.4</A>&nbsp;&nbsp;Credits</H2><!--SEC END -->


<FONT COLOR=purple>Frown</FONT> wouldn't have seen the light of day without the work of Ross
Paterson and Doaitse Swierstra. Ross invoked my interest in LR parsing
and he devised the <TT>--code=stackless</TT> and <TT>--code=gvstack</TT> output
formats. Doaitse invented the <TT>--code=standard</TT> format, which was
historically the first format <FONT COLOR=purple>Frown</FONT> supported.<BR>
<BR>
A big thank you goes to Andres Löh and Ross Paterson for various bug
reports and suggestions for improvement.<BR>
<BR>
<!--BEGIN NOTES chapter-->
<HR WIDTH="50%" SIZE=1><DL CLASS="list"><DT CLASS="dt-list"><A NAME="note1" HREF="#text1"><FONT SIZE=5>1</FONT></A><DD CLASS="dd-list">There are some known problems. The
 format <TT>code=stackless</TT> behaves differently for <TT>Loop.g</TT> (the
 generated parser is less strict than the standard one). Also,
 <TT>Empty.g</TT> does not work yet. Finally, error reports may differ for
 different formats and for optimized and unoptimized versions (as some
 parsers perform additional reductions before an error is
 reported).
</DL>
<!--END NOTES-->
<!--TOC chapter Quick start-->

<H1 CLASS="chapter"><A NAME="htoc6">Chapter&nbsp;2</A>&nbsp;&nbsp;Quick start</H1><!--SEC END -->


First install <FONT COLOR=purple>Frown</FONT> as described in Sec.&nbsp;<A HREF="#sec:install">1.1</A>. Then enter
the directory <TT>QuickStart</TT>.
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&nbsp;ralf/Frown&gt;&nbsp;cd&nbsp;QuickStart
</TT></TD>
</TR></TABLE>
The file <TT>Tiger.lg</TT>, listed in Fig.&nbsp;<A HREF="#fig:tiger">2.1</A>, contains a
medium-sized grammar for an imperative language.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<FONT SIZE=2>A grammar file consists of two parts: the specification of the
grammar, enclosed in special curly braces, and Haskell source code.
The source file typically starts with a Haskell module header.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
</FONT><TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Tiger</I></TT></FONT><FONT SIZE=2><TT>&nbsp;<B>where</B></TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Lexer</I></TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Syntax</I></TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Prelude</I></TT></FONT><FONT SIZE=2><TT>&nbsp;hiding&nbsp;(exp)</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;%{</TT></FONT></TD>
</TR></TABLE><FONT SIZE=2>

</TD></TR></TABLE><P>
The grammar part begins here. A context-free grammar consists of sets
of terminal and nonterminal symbols, a set of start symbols, and set
of productions or grammar rules. The declaration below introduces the
terminal symbols. Each terminal is given by a Haskell pattern of type
<TT><I>Terminal</I></TT></FONT><FONT SIZE=2>.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
</FONT><TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;=&nbsp;&nbsp;<I>DO</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;&nbsp;<I>ELSE</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;&nbsp;<I>END</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>FUNCTION</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;&nbsp;<I>IF</I></TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>IN</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;&nbsp;<I>LET</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>THEN</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;|&nbsp;&nbsp;<I>VAR</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>WHILE</I></TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>ASSIGN</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;as&nbsp;":="&nbsp;&nbsp;|&nbsp;&nbsp;<I>COLON</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;as&nbsp;":"&nbsp;&nbsp;|&nbsp;&nbsp;<I>COMMA</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;as&nbsp;","&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>CPAREN</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;as&nbsp;")"</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>DIV</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"/"&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>EQU</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"="&nbsp;&nbsp;|&nbsp;&nbsp;<I>LST</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"&lt;="&nbsp;&nbsp;|&nbsp;&nbsp;<I>MINUS</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;as&nbsp;"-"</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>NEG</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"~"&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>OPAREN</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;as&nbsp;"("&nbsp;&nbsp;|&nbsp;&nbsp;<I>PLUS</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"+"&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>SEMI</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;";"</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>TIMES</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;as&nbsp;"*"</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>ID</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;&nbsp;{<I>String</I></TT></FONT><FONT SIZE=2><TT>}&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>INT</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;{<I>String</I></TT></FONT><FONT SIZE=2><TT>};
</TT></FONT></TD>
</TR></TABLE><FONT SIZE=2>

</TD></TR></TABLE><P>
A terminal symbol may carry a semantic value or attribute. The Haskell
type of the semantic value is given in curly braces. As a rule,
Haskell source code is always enclosed in curly braces within the
grammar part. The as-clauses define shortcuts for terminals, which may
then be used in the productions.<BR>
<BR>
The declaration below introduces a nonterminal symbol called <TT>exp</TT>
followed by sixteen productions for that symbol. The asterix marks
<TT>exp</TT> as a start symbol; <TT>exp</TT> has a single attribute of type <TT><I>Expr</I></TT></FONT><FONT SIZE=2>.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
</FONT><TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;*exp&nbsp;&nbsp;{<I>Expr</I></TT></FONT><FONT SIZE=2><TT>};</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;exp&nbsp;&nbsp;{<I>Var</I></TT></FONT><FONT SIZE=2><TT>&nbsp;v}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;<I>ID</I></TT></FONT><FONT SIZE=2><TT>&nbsp;{v};</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Block</I></TT></FONT><FONT SIZE=2><TT>&nbsp;es}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"(",&nbsp;sepBy&nbsp;exp&nbsp;";"&nbsp;{es},&nbsp;")";</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Int</I></TT></FONT><FONT SIZE=2><TT>&nbsp;i&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>INT</I></TT></FONT><FONT SIZE=2><TT>&nbsp;{i};</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Un</I></TT></FONT><FONT SIZE=2><TT>&nbsp;<I>Neg</I></TT></FONT><FONT SIZE=2><TT>&nbsp;e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"-",&nbsp;exp&nbsp;{e},&nbsp;prec&nbsp;"~";</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Call</I></TT></FONT><FONT SIZE=2><TT>&nbsp;f&nbsp;es}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>ID</I></TT></FONT><FONT SIZE=2><TT>&nbsp;{f},&nbsp;"(",&nbsp;sepBy&nbsp;exp&nbsp;","&nbsp;{es},&nbsp;")";</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Bin</I></TT></FONT><FONT SIZE=2><TT>&nbsp;e1&nbsp;<I>Eq</I></TT></FONT><FONT SIZE=2><TT>&nbsp;&nbsp;e2}&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;exp&nbsp;{e1},&nbsp;"=",&nbsp;&nbsp;exp&nbsp;{e2};</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Bin</I></TT></FONT><FONT SIZE=2><TT>&nbsp;e1&nbsp;<I>Leq</I></TT></FONT><FONT SIZE=2><TT>&nbsp;e2}&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;exp&nbsp;{e1},&nbsp;"&lt;=",&nbsp;exp&nbsp;{e2};</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Bin</I></TT></FONT><FONT SIZE=2><TT>&nbsp;e1&nbsp;<I>Add</I></TT></FONT><FONT SIZE=2><TT>&nbsp;e2}&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;exp&nbsp;{e1},&nbsp;"+",&nbsp;&nbsp;exp&nbsp;{e2};</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Bin</I></TT></FONT><FONT SIZE=2><TT>&nbsp;e1&nbsp;<I>Sub</I></TT></FONT><FONT SIZE=2><TT>&nbsp;e2}&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;exp&nbsp;{e1},&nbsp;"-",&nbsp;&nbsp;exp&nbsp;{e2};</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Bin</I></TT></FONT><FONT SIZE=2><TT>&nbsp;e1&nbsp;<I>Mul</I></TT></FONT><FONT SIZE=2><TT>&nbsp;e2}&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;exp&nbsp;{e1},&nbsp;"*",&nbsp;&nbsp;exp&nbsp;{e2};</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Bin</I></TT></FONT><FONT SIZE=2><TT>&nbsp;e1&nbsp;<I>Div</I></TT></FONT><FONT SIZE=2><TT>&nbsp;e2}&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;exp&nbsp;{e1},&nbsp;"/",&nbsp;&nbsp;exp&nbsp;{e2};</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Assign</I></TT></FONT><FONT SIZE=2><TT>&nbsp;v&nbsp;e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>ID</I></TT></FONT><FONT SIZE=2><TT>&nbsp;{v},&nbsp;":=",&nbsp;&nbsp;exp&nbsp;{e};</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>IfThen</I></TT></FONT><FONT SIZE=2><TT>&nbsp;e&nbsp;e1}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>IF</I></TT></FONT><FONT SIZE=2><TT>,&nbsp;exp&nbsp;{e},&nbsp;<I>THEN</I></TT></FONT><FONT SIZE=2><TT>,&nbsp;exp&nbsp;{e1};</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>IfElse</I></TT></FONT><FONT SIZE=2><TT>&nbsp;e&nbsp;e1&nbsp;e2}&nbsp;&nbsp;|&nbsp;&nbsp;<I>IF</I></TT></FONT><FONT SIZE=2><TT>,&nbsp;exp&nbsp;{e},&nbsp;<I>THEN</I></TT></FONT><FONT SIZE=2><TT>,&nbsp;exp&nbsp;{e1},&nbsp;<I>ELSE</I></TT></FONT><FONT SIZE=2><TT>,&nbsp;exp&nbsp;{e2};</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>While</I></TT></FONT><FONT SIZE=2><TT>&nbsp;e&nbsp;e1}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>WHILE</I></TT></FONT><FONT SIZE=2><TT>,&nbsp;exp&nbsp;{e},&nbsp;<I>DO</I></TT></FONT><FONT SIZE=2><TT>,&nbsp;exp&nbsp;{e1};</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Let</I></TT></FONT><FONT SIZE=2><TT>&nbsp;ds&nbsp;es}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>LET</I></TT></FONT><FONT SIZE=2><TT>,&nbsp;many&nbsp;dec&nbsp;{ds},&nbsp;<I>IN</I></TT></FONT><FONT SIZE=2><TT>,&nbsp;sepBy&nbsp;exp&nbsp;";"&nbsp;{es},&nbsp;<I>END</I></TT></FONT><FONT SIZE=2><TT>;
</TT></FONT></TD>
</TR></TABLE><FONT SIZE=2>

</TD></TR></TABLE><P>
Left-hand and right-hand side of a production are separated by a
colon; symbols on the right are separated by commas and terminated by
a semicolon. Alternative right-hand sides are separated by a vertical
bar. <BR>
<BR>
The pieces in curly braces constitute Haskell source code. Each rule
can be seen as a function from the right-hand to the left-hand
side. On the right-hand side, Haskell variables are used to name the
values of attributes. The values of the attributes on the left-hand
side are given by Haskell expressions, in which the variables of the
right-hand side occur free.<BR>
<BR>
The last production makes use of two (predefined) rule schemes: <TT>many&nbsp;x</TT>
implements the repetition of the symbol <TT>x</TT>, and <TT>sepBy&nbsp;x&nbsp;sep</TT>
denotes a repetition of <TT>x</TT> symbols separated by <TT>sep</TT> symbols.<BR>
<BR>
The above productions are ambiguous as, for instance, <TT>1&nbsp;+&nbsp;2&nbsp;*&nbsp;3</TT> has
two derivations. The ambiguity can be resolved by assigning
precedences to terminal symbols.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
</FONT><TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;left&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;"~";&nbsp;&nbsp;&nbsp;left&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;"*";&nbsp;&nbsp;&nbsp;left&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;"/";&nbsp;&nbsp;left&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;"+";&nbsp;&nbsp;left&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;"-";</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;right&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;<I>THEN</I></TT></FONT><FONT SIZE=2><TT>;&nbsp;&nbsp;right&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;<I>ELSE</I></TT></FONT><FONT SIZE=2><TT>;&nbsp;&nbsp;</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;nonassoc&nbsp;&nbsp;4&nbsp;&nbsp;"&lt;=";&nbsp;&nbsp;nonassoc&nbsp;&nbsp;4&nbsp;&nbsp;"=";&nbsp;&nbsp;&nbsp;nonassoc&nbsp;&nbsp;0&nbsp;&nbsp;<I>DO</I></TT></FONT><FONT SIZE=2><TT>;&nbsp;&nbsp;&nbsp;nonassoc&nbsp;&nbsp;0&nbsp;&nbsp;":=";
</TT></FONT></TD>
</TR></TABLE><FONT SIZE=2>

</TD></TR></TABLE><P>
The following declarations define the nonterminal <TT>dec</TT> and three
further nonterminals.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
</FONT><TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;dec&nbsp;&nbsp;{<I>Decl</I></TT></FONT><FONT SIZE=2><TT>};</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;dec&nbsp;&nbsp;{d}&nbsp;&nbsp;:&nbsp;&nbsp;vardec&nbsp;{d};</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{d}&nbsp;&nbsp;|&nbsp;&nbsp;fundec&nbsp;{d};</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;vardec&nbsp;&nbsp;{<I>Decl</I></TT></FONT><FONT SIZE=2><TT>};</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;vardec&nbsp;&nbsp;{<I>Variable</I></TT></FONT><FONT SIZE=2><TT>&nbsp;v&nbsp;e}&nbsp;&nbsp;:&nbsp;&nbsp;<I>VAR</I></TT></FONT><FONT SIZE=2><TT>,&nbsp;<I>ID</I></TT></FONT><FONT SIZE=2><TT>&nbsp;{v},&nbsp;":=",&nbsp;exp&nbsp;{e};</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;fundec&nbsp;&nbsp;{<I>Decl</I></TT></FONT><FONT SIZE=2><TT>};</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;fundec&nbsp;&nbsp;{<I>Function</I></TT></FONT><FONT SIZE=2><TT>&nbsp;f&nbsp;xs&nbsp;e}&nbsp;&nbsp;:&nbsp;&nbsp;<I>FUNCTION</I></TT></FONT><FONT SIZE=2><TT>,&nbsp;<I>ID</I></TT></FONT><FONT SIZE=2><TT>&nbsp;{f},&nbsp;"(",&nbsp;sepBy&nbsp;(<I>ID</I></TT></FONT><FONT SIZE=2><TT>&nbsp;{})&nbsp;","&nbsp;{xs},&nbsp;")",&nbsp;"=",&nbsp;exp&nbsp;{e};</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;formal&nbsp;&nbsp;{(<I>Ident</I></TT></FONT><FONT SIZE=2><TT>,&nbsp;<I>TyIdent</I></TT></FONT><FONT SIZE=2><TT>)};</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;formal&nbsp;&nbsp;{(v,&nbsp;t)}&nbsp;&nbsp;:&nbsp;&nbsp;<I>ID</I></TT></FONT><FONT SIZE=2><TT>&nbsp;{v},&nbsp;":",&nbsp;<I>ID</I></TT></FONT><FONT SIZE=2><TT>&nbsp;{t};</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;}%
</TT></FONT></TD>
</TR></TABLE><FONT SIZE=2>

</TD></TR></TABLE><P>
The grammar part ends here. The source file typically includes a
couple of Haskell declarations. The user-defined function <TT>frown</TT> is
the error routine invoked by the parser in case of a syntax error; its
definition is mandatory.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
</FONT><TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;frown&nbsp;_&nbsp;&nbsp;=&nbsp;&nbsp;error&nbsp;"syntax&nbsp;error"</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;tc&nbsp;f&nbsp;&nbsp;=&nbsp;&nbsp;<B>do</B>&nbsp;{&nbsp;&nbsp;putStrLn&nbsp;"***&nbsp;reading&nbsp;...";&nbsp;&nbsp;s&nbsp;&lt;-&nbsp;readFile&nbsp;f;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;s;</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;putStrLn&nbsp;"***&nbsp;lexing&nbsp;&nbsp;...";&nbsp;&nbsp;<B>let</B>&nbsp;{ts&nbsp;=&nbsp;lexer&nbsp;s};&nbsp;&nbsp;print&nbsp;ts;</TT></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;putStrLn&nbsp;"***&nbsp;parsing&nbsp;...";&nbsp;&nbsp;e&nbsp;&lt;-&nbsp;exp&nbsp;ts;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;e&nbsp;}</TT></FONT></TD>
</TR></TABLE><FONT SIZE=2>

</TD></TR></TABLE><P>
<BR>
<BR>
</FONT><DIV CLASS="center"><FONT SIZE=2>Figure 2.1: </FONT><A NAME="fig:tiger"></A><FONT SIZE=2>A sample <FONT COLOR=purple>Frown</FONT></FONT><FONT SIZE=2> grammar file.</FONT></DIV><BR>
<BR>
<FONT SIZE=2>
</FONT><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
Now, type
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&nbsp;ralf/Frown/QuickStart&gt;&nbsp;frown&nbsp;-v&nbsp;Tiger.lg</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&nbsp;ralf/Frown/QuickStart&gt;&nbsp;hugs&nbsp;Tiger.hs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&nbsp;...</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&nbsp;Tiger&gt;&nbsp;exp&nbsp;[ID&nbsp;"a",&nbsp;PLUS,&nbsp;ID&nbsp;"b",&nbsp;TIMES,&nbsp;INT&nbsp;"2"]&nbsp;&gt;&gt;=&nbsp;print</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&nbsp;Bin&nbsp;(Var&nbsp;"a")&nbsp;Add&nbsp;(Bin&nbsp;(Var&nbsp;"b")&nbsp;Mul&nbsp;(Int&nbsp;"2"))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&nbsp;Tiger&gt;&nbsp;tc&nbsp;"fib.tig"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&nbsp;...
</TT></TD>
</TR></TABLE>
The call <TT>frown&nbsp;-v&nbsp;Tiger.lg</TT> generates a Haskell parser which can then
be loaded into <TT>hugs</TT> (or <TT>ghci</TT>). The parser has type <TT>exp&nbsp;::&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;[<I>Terminal</I></TT><TT>]&nbsp;-&gt;&nbsp;m&nbsp;<I>Expr</I></TT>, that is, the parser is a computation that
takes a list of terminals as input and returns an expression.<BR>
<BR>
<BR>

More examples can be found in the directory <TT>Manual/Examples</TT>:
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description">
<B><TT>Paren1.lg</TT></B><DD CLASS="dd-description"><BR>
well-balanced parentheses: a pure grammar (see Sec.&nbsp;<A HREF="#sec:pure">3.2.1</A>);<BR>
<BR>
<DT CLASS="dt-description"><B><TT>Paren2.lg</TT></B><DD CLASS="dd-description"><BR>
an extension of <TT>Paren1.lg</TT> illustrating the definition of attributes
(see Sec.&nbsp;<A HREF="#sec:attributes">3.2.2</A>);<BR>
<BR>
<DT CLASS="dt-description"><B><TT>Calc.lg</TT></B><DD CLASS="dd-description"><BR>
a simple evaluator for arithmetic expressions: a parser that
interfaces with a separate lexer (see Sec.&nbsp;<A HREF="#sec:lexer">3.2.3</A>);<BR>
<BR>
<DT CLASS="dt-description"><B><TT>MCalc.lg</TT></B><DD CLASS="dd-description"><BR>
a variant of the desktop calculator (<TT>Calc.lg</TT>) that prints all
intermediate results: illustrates monadic actions (see
Sec.&nbsp;<A HREF="#sec:monadicactions">3.2.4</A>);<BR>
<BR>
<DT CLASS="dt-description"><B><TT>Let1.lg</TT></B><DD CLASS="dd-description"><BR>
an ambiguous expression grammar: illustrates backtracking parsers (see
Sec.&nbsp;<A HREF="#sec:backtracking">3.2.5</A>);<BR>
<BR>
<DT CLASS="dt-description"><B><TT>Let2.lg</TT></B><DD CLASS="dd-description"><BR>
an expression grammar: illustrates the use of precedences and
associativity (see Sec.&nbsp;<A HREF="#sec:prec">3.2.6</A>);<BR>
<BR>
<DT CLASS="dt-description"><B><TT>Let3.lg</TT></B><DD CLASS="dd-description"><BR>
a variant of the expression grammar: shows how to simulate inherited
attributes using a reader monad (see Sec.&nbsp;<A HREF="#sec:reader">3.2.8</A>);<BR>
<BR>
<DT CLASS="dt-description"><B><TT>Let4.lg</TT></B><DD CLASS="dd-description"><BR>
an expression grammar: illustrates a parser
that interfaces with a monadic lexer (see Sec.&nbsp;<A HREF="#sec:mlexer">3.3.1</A>);<BR>
<BR>
<DT CLASS="dt-description"><B><TT>Let5.lg</TT></B><DD CLASS="dd-description"><BR>
a variant of <TT>Let4.lg</TT> with better error reporting (see
Sec.&nbsp;<A HREF="#sec:reporting">3.3.2</A>);<BR>
<BR>
<DT CLASS="dt-description"><B><TT>Let6.lg</TT></B><DD CLASS="dd-description"><BR>
a variant of <TT>Let5.lg</TT> with even better error reporting: prints a
list of expected tokens upon error (see Sec.&nbsp;<A HREF="#sec:expected">3.3.3</A>);<BR>
<BR>
<DT CLASS="dt-description"><B><TT>Let7.lg</TT></B><DD CLASS="dd-description"><BR>
yet another variant of the expression grammar: illustrates a simple
form of error correction (see Sec.&nbsp;<A HREF="#sec:errorcorrection">3.3.4</A>);<BR>
<BR>
<DT CLASS="dt-description"><B><TT>Let8.lg</TT></B><DD CLASS="dd-description"><BR>
variant of <TT>Let7.lg</TT> that notifies the user of corrections (see
Sec.&nbsp;<A HREF="#sec:errorcorrection">3.3.4</A>);<BR>
<BR>
<DT CLASS="dt-description"><B><TT>VarCalc.lg</TT></B><DD CLASS="dd-description"><BR>
a variant of the desktop calculator (<TT>Calc.lg</TT>) that works without a
separate lexer: illustrates guards (see Sec.&nbsp;<A HREF="#sec:terminal2">3.4.2</A>);<BR>
<BR>
<DT CLASS="dt-description"><B><TT>Paren3.lg</TT></B><DD CLASS="dd-description"><BR>
illustrates the tracing facilities (see Sec.&nbsp;<A HREF="#sec:tracing">3.4.4</A>);<BR>
<BR>
<DT CLASS="dt-description"><B><TT>VarParen.lg</TT></B><DD CLASS="dd-description"><BR>
illustrates irrefutable patterns on the right-hand side of productions
(see Sec.&nbsp;<A HREF="#sec:irrefutable">4.1</A>);<BR>
<BR>
<DT CLASS="dt-description"><B><TT>RepMin.lg</TT></B><DD CLASS="dd-description"><BR>
a solution to the rep-min problem: illustrates how to simulate
inherited attributes using functional attributes (see
Sec.&nbsp;<A HREF="#sec:inherited">4.2</A>).
</DL>
<!--TOC chapter Tour de <FONT COLOR=purple>Frown</FONT>-->

<H1 CLASS="chapter"><A NAME="htoc7">Chapter&nbsp;3</A>&nbsp;&nbsp;Tour de <FONT COLOR=purple>Frown</FONT></H1><!--SEC END -->


This chapter introduces <FONT COLOR=purple>Frown</FONT> by means of example.<BR>
<BR>
<!--TOC section Preliminaries: monads-->

<H2 CLASS="section"><A NAME="htoc8">3.1</A>&nbsp;&nbsp;Preliminaries: monads</H2><!--SEC END -->


Some elementary knowledge of <I><FONT COLOR=maroon>monads</FONT></I> is helpful in order to
use <FONT COLOR=purple>Frown</FONT> effectively. For the most basic applications, however, one
can possibly do without. This section summarizes the relevant facts.<BR>
<BR>
In Haskell, the concept of a monad is captured by the following
class definition.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>class</B>&nbsp;<I>Monad</I></TT><TT>&nbsp;m&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;a&nbsp;-&gt;&nbsp;m&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&gt;&gt;=)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;m&nbsp;a&nbsp;-&gt;&nbsp;(a&nbsp;-&gt;&nbsp;m&nbsp;b)&nbsp;-&gt;&nbsp;m&nbsp;b</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&gt;&gt;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;m&nbsp;a&nbsp;-&gt;&nbsp;m&nbsp;b&nbsp;-&gt;&nbsp;m&nbsp;b</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;m&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;&gt;&gt;&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;m&nbsp;&gt;&gt;=&nbsp;const&nbsp;n</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;error&nbsp;s
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The essential idea of monads is to distinguish between
<I><FONT COLOR=maroon>computations</FONT></I> and <I><FONT COLOR=maroon>values</FONT></I>. This distinction is
reflected on the type level: an element of <TT>m&nbsp;a</TT> represents a
computation that yields a value of type <TT>a</TT>. The trivial or pure
computation that immediately returns the value <TT>a</TT> is denoted <TT>return&nbsp;a</TT>. The operator <TT>(&gt;&gt;=)</TT>, commonly called `bind', combines two
computations: <TT>m&nbsp;&gt;&gt;=&nbsp;k</TT> applies <TT>k</TT> to the result of the computation
<TT>m</TT>. The derived operation <TT>(&gt;&gt;)</TT> provides a handy shortcut if one is
not interested in the result of the first computation. Finally, the
operation <TT>fail</TT> is useful for signaling error conditions (a common
thing in parsing).<BR>
<BR>
Framing the concept of a monad as a type class is sensible for at
least two interrelated reasons. First, we can use the same names
(<TT>return</TT>, `<TT>&gt;&gt;=</TT>', and <TT>fail</TT>) for wildly different computational
structures.<SUP><A NAME="text2" HREF="#note2">1</A></SUP> Second, by overloading a function with
the monad class we effectively parameterize the function by
computational structures, that is, we can call the same function with
different instances of monads obtaining different computational
effects.<BR>
<BR>
The following instance declaration (<TT>Result.lhs</TT>) defines a simple
monad that we will use intensively in the sequel (the monad can be
seen as a simplified term implementation of the basic monad
operations).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Result</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>data</B>&nbsp;<I>Result</I></TT><TT>&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Return</I></TT><TT>&nbsp;a&nbsp;|&nbsp;<I>Fail</I></TT><TT>&nbsp;<I>String</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>deriving</B>&nbsp;(<I>Show</I></TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>instance</B>&nbsp;<I>Monad</I></TT><TT>&nbsp;<I>Result</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Return</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Fail</I></TT><TT>&nbsp;s&nbsp;&nbsp;&nbsp;&gt;&gt;=&nbsp;k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Fail</I></TT><TT>&nbsp;s</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Return</I></TT><TT>&nbsp;a&nbsp;&gt;&gt;=&nbsp;k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;k&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Fail</I></TT><TT>
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
In monad speak, this is an <I><FONT COLOR=maroon>exception monad</FONT></I>: a computation
in <TT><I>Result</I></TT> either succeeds gracefully yielding a value <TT>a</TT>
(represented by the term <TT><I>Return</I></TT><TT>&nbsp;a</TT>) or it fails with an error message
<TT>s</TT> (represented by <TT><I>Fail</I></TT><TT>&nbsp;s</TT>). That's all we initially need for
<FONT COLOR=purple>Frown</FONT>: parsing a given input either succeeds producing a semantic
value (sometimes called an attribution) or it fails (hopefully, with a
clear indication of the syntax error).<BR>
<BR>
<!--TOC section Basic features-->

<H2 CLASS="section"><A NAME="htoc9">3.2</A>&nbsp;&nbsp;Basic features</H2><!--SEC END -->


<!--TOC subsection Pure grammars-->

<H3 CLASS="subsection"><A NAME="htoc10">3.2.1</A>&nbsp;&nbsp;Pure grammars</H3><!--SEC END -->

<A NAME="sec:pure"></A>

Let's start with a simple example. The following complete <FONT COLOR=purple>Frown</FONT>
source file (<TT>Paren1.lg</TT><SUP><A NAME="text3" HREF="#note3">2</A></SUP>) defines the language of
well-balanced parentheses. The specification of the grammar is
enclosed in special curly braces `<TT>%{&nbsp;ldots&nbsp;}%</TT>'. The remainder
contains Haskell source code, that is, a module header and a function
declaration.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Paren</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Result</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;%{</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;'('&nbsp;|&nbsp;')';</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Nonterminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;paren;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;paren,&nbsp;'(',&nbsp;paren,&nbsp;')';</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;}%</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;fail&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The part enclosed in special curly braces comprises the typical
ingredients of a <I><FONT COLOR=maroon>context-free grammar</FONT></I>: a declaration of
the <I><FONT COLOR=maroon>terminal symbols</FONT></I>, a declaration of the
<I><FONT COLOR=maroon>nonterminal symbols</FONT></I>, and finally the
<I><FONT COLOR=maroon>productions</FONT></I> or <I><FONT COLOR=maroon>grammar rules</FONT></I>.<BR>
<BR>
In general, the terminal symbols are given by Haskell patterns of the
same type. Here, we have two character patterns of type <TT><I>Char</I></TT>.<BR>
<BR>
Nonterminals are just identifiers starting with a lower-case letter.
By convention, the first nonterminal is also the start symbol of
the grammar (this default can be overwritten, see&nbsp;Sec.&nbsp;<A HREF="#sec:multiple">3.2.7</A>).<BR>
<BR>
Productions have the general form <TT>n&nbsp;:&nbsp;v_1,&nbsp;ldots,&nbsp;v_k;</TT> where <TT>n</TT> is
a nonterminal and <TT>v_1</TT>, ..., <TT>v_k</TT> are symbols. Note that the
symbols are separated by commas and terminated by a semicolon. The
mandatory trailing semicolon helps to identify so-called
<I><FONT COLOR=maroon>&#1108;-productions</FONT></I>, productions with an empty right-hand
side, such as <TT>paren&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;;</TT>.<BR>
<BR>
As a shorthand, we allow to list several alternative right-hand sides
separated by a vertical bar. Thus, the above productions could have
been written more succinctly as

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;paren,&nbsp;'(',&nbsp;paren,&nbsp;')';
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The two styles can be arbitrarily mixed. In fact, it is not even
required that productions with the same left-hand side are grouped
together (though it is good style to do so).<BR>
<BR>
Now, assuming that the above grammar resides in a file called
<TT>Paren.g</TT> we can generate a Haskell parser by issuing the command
<BLOCKQUOTE CLASS="quote">
<TT>frown&nbsp;Paren.g</TT>
</BLOCKQUOTE>
This produces a Haskell source file named <TT>Paren.hs</TT> that contains
among other things the function

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;[<I>Char</I></TT><TT>]&nbsp;-&gt;&nbsp;m&nbsp;()&nbsp;,
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
which recognizes the language generated by the start symbol of the
same name. Specifically, if <TT>inp</TT> is a list of characters, then
<TT>paren&nbsp;inp</TT> is a computation that either succeeds indicating that
<TT>inp</TT> is a well-formed parentheses or fails indicating that <TT>inp</TT>
isn't well-formed. Here is a short interactive session using the
Haskell interpreter Hugs (type <TT>hugs&nbsp;Paren.hs</TT> at the command line).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Paren</I></TT><TT>&gt;&gt;&nbsp;paren&nbsp;"(())()"&nbsp;::&nbsp;<I>Result</I></TT><TT>&nbsp;()</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Return</I></TT><TT>&nbsp;()</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Paren</I></TT><TT>&gt;&gt;&nbsp;paren&nbsp;"(())("&nbsp;&nbsp;::&nbsp;<I>Result</I></TT><TT>&nbsp;()</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Fail</I></TT><TT>&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Note that we have to specify the result type of the expressions in
order to avoid an unresolved overloading error. Or to put it
differently, we have to specify the monad, in which the parsing
process takes place. Of course, we are free to assign <TT>paren</TT> a more
constrained type by placing an appropriate type signature in the
Haskell section of the grammar file:

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;[<I>Char</I></TT><TT>]&nbsp;-&gt;&nbsp;<I>Result</I></TT><TT>&nbsp;()&nbsp;.
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
By the way, since the nonterminal <TT>paren</TT> carries no semantic value,
the type of the computation is simply <TT><I>Result</I></TT><TT>&nbsp;()</TT> where the empty
tuple type `<TT>()</TT>' serves as a dummy type. In the next section we will
show how to add attributes or semantic values to nonterminals.<BR>
<BR>
Every once in a while parsing fails. In this case, <FONT COLOR=purple>Frown</FONT> calls a
user-supplied function named, well, <TT>frown</TT> (note that you must supply
this function). In our example, <TT>frown</TT> has type

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;[<I>Char</I></TT><TT>]&nbsp;-&gt;&nbsp;m&nbsp;a
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The error function <TT>frown</TT> is passed the remaining input as an
argument, that you can give an indication of the location of the
syntax error (more on error reporting in
Sec.&nbsp;<A HREF="#sec:error-reporting">3.3</A>). Note that <TT>frown</TT> must be polymorphic
in the result type.<BR>
<BR>
<DIV CLASS="flushleft"><B>Remark&nbsp;1</B>&nbsp;&nbsp;<EM>
 For those of you who are knowledgable and/or interested in
 LR&nbsp;parsing, Fig.&nbsp;</EM><A HREF="#fig:ex1"><EM>3.1</EM></A><EM> displays the Haskell file that is
 generated by <TT>frown&nbsp;Paren.g</TT></EM><SUP><A NAME="text4" HREF="#note4"><EM>3</EM></A></SUP><EM>. For each state <TT>i</TT> of the underlying
 LR</EM>(<EM>0</EM>)<EM> automaton, displayed in Fig.&nbsp;</EM><A HREF="#fig:auto1"><EM>3.2</EM></A><EM>,
 there is one function called <TT>parse_i</TT>. All these functions take two
 arguments: the remaining input and a stack that records the
 transitions of the LR</EM>(<EM>0</EM>)<EM> machine. The reader is
 invited to trace the parse of <TT>"(())()"</TT>.
</EM><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><EM>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
</EM><TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Paren</I></TT></EM><EM><TT>&nbsp;<B>where</B></TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Result</I></TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;</TT>{- frown :-( -}</EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;<B>data</B>&nbsp;<I>Stack</I></TT></EM><EM><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Empty</I></TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>T_1_2</I></TT></EM><EM><TT>&nbsp;<I>Stack</I></TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>T_2_3</I></TT></EM><EM><TT>&nbsp;<I>Stack</I></TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>T_2_5</I></TT></EM><EM><TT>&nbsp;<I>Stack</I></TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>T_4_5</I></TT></EM><EM><TT>&nbsp;<I>Stack</I></TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>T_4_6</I></TT></EM><EM><TT>&nbsp;<I>Stack</I></TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>T_5_4</I></TT></EM><EM><TT>&nbsp;<I>Stack</I></TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;<B>data</B>&nbsp;<I>Nonterminal</I></TT></EM><EM><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Paren</I></TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;paren&nbsp;tr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_1&nbsp;tr&nbsp;<I>Empty</I></TT></EM><EM><TT>&nbsp;&gt;&gt;=&nbsp;(\&nbsp;<I>Paren</I></TT></EM><EM><TT>&nbsp;-&gt;&nbsp;return&nbsp;())</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;parse_1&nbsp;ts&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_2&nbsp;ts&nbsp;(<I>T_1_2</I></TT></EM><EM><TT>&nbsp;st)</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;parse_2&nbsp;tr@[]&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_3&nbsp;tr&nbsp;(<I>T_2_3</I></TT></EM><EM><TT>&nbsp;st)</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;parse_2&nbsp;('('&nbsp;:&nbsp;tr)&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_5&nbsp;tr&nbsp;(<I>T_2_5</I></TT></EM><EM><TT>&nbsp;st)</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;parse_2&nbsp;ts&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;frown&nbsp;ts</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;parse_3&nbsp;ts&nbsp;(<I>T_2_3</I></TT></EM><EM><TT>&nbsp;(<I>T_1_2</I></TT></EM><EM><TT>&nbsp;st))&nbsp;&nbsp;=&nbsp;&nbsp;return&nbsp;<I>Paren</I></TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;parse_4&nbsp;('('&nbsp;:&nbsp;tr)&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_5&nbsp;tr&nbsp;(<I>T_4_5</I></TT></EM><EM><TT>&nbsp;st)</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;parse_4&nbsp;(')'&nbsp;:&nbsp;tr)&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_6&nbsp;tr&nbsp;(<I>T_4_6</I></TT></EM><EM><TT>&nbsp;st)</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;parse_4&nbsp;ts&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;frown&nbsp;ts</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;parse_5&nbsp;ts&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_4&nbsp;ts&nbsp;(<I>T_5_4</I></TT></EM><EM><TT>&nbsp;st)</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;parse_6&nbsp;ts&nbsp;(<I>T_4_6</I></TT></EM><EM><TT>&nbsp;(<I>T_5_4</I></TT></EM><EM><TT>&nbsp;(<I>T_2_5</I></TT></EM><EM><TT>&nbsp;(<I>T_1_2</I></TT></EM><EM><TT>&nbsp;st))))&nbsp;=&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_2&nbsp;ts&nbsp;(<I>T_1_2</I></TT></EM><EM><TT>&nbsp;st)</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;parse_6&nbsp;ts&nbsp;(<I>T_4_6</I></TT></EM><EM><TT>&nbsp;(<I>T_5_4</I></TT></EM><EM><TT>&nbsp;(<I>T_4_5</I></TT></EM><EM><TT>&nbsp;(<I>T_5_4</I></TT></EM><EM><TT>&nbsp;st))))</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_4&nbsp;ts&nbsp;(<I>T_5_4</I></TT></EM><EM><TT>&nbsp;st)</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;</TT>{- )-: frown -}</EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;</TT></EM></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><EM><TT>&gt;&nbsp;&nbsp;frown&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;fail&nbsp;"syntax&nbsp;error"</TT></EM></TD>
</TR></TABLE><EM>

</TD></TR></TABLE><P>
<BR>
<BR>
</EM><DIV CLASS="center"><EM>Figure 3.1: </EM><A NAME="fig:ex1"></A><EM>A <FONT COLOR=purple>Frown</FONT></EM><EM> generated parser.</EM></DIV><BR>
<BR>
<EM>
</EM><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><EM>
</EM><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><EM>
</EM><DIV CLASS="center"><EM>
<IMG SRC="Manual001.gif">
</EM></DIV><EM>
<BR>
<BR>
</EM><DIV CLASS="center"><EM>Figure 3.2: </EM><A NAME="fig:auto1"></A><EM>The LR(0) automaton underlying the parser of Fig.&nbsp;</EM><A HREF="#fig:ex1"><EM>3.1</EM></A><EM>.</EM></DIV><BR>
<BR>
<EM>
</EM><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><EM>
</EM></DIV><BR>
<BR>
<!--TOC subsection Attributes-->

<H3 CLASS="subsection"><A NAME="htoc11">3.2.2</A>&nbsp;&nbsp;Attributes</H3><!--SEC END -->

<A NAME="sec:attributes"></A>

Now, let's augment the grammar of Sec.&nbsp;<A HREF="#sec:pure">3.2.1</A> by semantic
values (<TT>Paren2.lg</TT>). Often, the parser converts a given input into
some kind of tree representation (the so-called <I><FONT COLOR=maroon>abstract
syntax tree</FONT></I>). To represent nested parentheses we simply use binary
trees (an alternative employing <TT>n</TT>-ary trees is given in
Sec.&nbsp;<A HREF="#sec:irrefutable">4.1</A>).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Paren</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Result</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>data</B>&nbsp;<I>Tree</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Leaf</I></TT><TT>&nbsp;|&nbsp;<I>Fork</I></TT><TT>&nbsp;<I>Tree</I></TT><TT>&nbsp;<I>Tree</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>deriving</B>&nbsp;(<I>Show</I></TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;%{</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;'('&nbsp;|&nbsp;')';</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Nonterminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;paren&nbsp;{<I>Tree</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;&nbsp;{<I>Leaf</I></TT><TT>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Fork</I></TT><TT>&nbsp;t&nbsp;u}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;paren&nbsp;{t},&nbsp;'(',&nbsp;paren&nbsp;{u},&nbsp;')';</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;}%</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;fail&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Attributes are always given in curly braces. When we declare a
nonterminal, we have to specify the types of its attributes as in
<TT>paren&nbsp;{<I>Tree</I></TT><TT>}</TT>. The rules of the grammar can be seen as functions from
the right-hand side to the left-hand side. On the right-hand side,
Haskell variables are used to name the values of attributes. The
values of the attributes on the left-hand side are then given by
Haskell expressions, in which the variables of the right-hand side may
occur free. The Haskell expressions can be arbitrary, except that they
must not be layout-sensitive.<BR>
<BR>
In general, a nonterminal may have an arbitrary number of attributes
(see Sec.&nbsp;<A HREF="#sec:multattr">4.4</A> for an example). Note that <FONT COLOR=purple>Frown</FONT> only
supports so-called <I><FONT COLOR=maroon>synthesized attributes</FONT></I>
(<I><FONT COLOR=maroon>inherited attributes</FONT></I> can be simulated, however, with the
help of a reader monad, see Sec.&nbsp;<A HREF="#sec:reader">3.2.8</A>, or with functional
attributes, see Sec.&nbsp;<A HREF="#sec:inherited">4.2</A>).<BR>
<BR>
The parser generated by <FONT COLOR=purple>Frown</FONT> now has type

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;[<I>Char</I></TT><TT>]&nbsp;-&gt;&nbsp;m&nbsp;<I>Tree</I></TT><TT>&nbsp;.
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The following interactive session illustrates its use.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Paren</I></TT><TT>&gt;&gt;&nbsp;paren&nbsp;"(())()"&nbsp;::&nbsp;<I>Result</I></TT><TT>&nbsp;<I>Tree</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Return</I></TT><TT>&nbsp;(<I>Fork</I></TT><TT>&nbsp;(<I>Fork</I></TT><TT>&nbsp;<I>Leaf</I></TT><TT>&nbsp;(<I>Fork</I></TT><TT>&nbsp;<I>Leaf</I></TT><TT>&nbsp;<I>Leaf</I></TT><TT>))&nbsp;<I>Leaf</I></TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Paren</I></TT><TT>&gt;&gt;&nbsp;paren&nbsp;"(())("&nbsp;::&nbsp;<I>Result</I></TT><TT>&nbsp;<I>Tree</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Fail</I></TT><TT>&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<!--TOC subsection Interfacing with a lexer-->

<H3 CLASS="subsection"><A NAME="htoc12">3.2.3</A>&nbsp;&nbsp;Interfacing with a lexer</H3><!--SEC END -->

<A NAME="sec:lexer"></A>

The parsers of the two previous sections take a list of characters as
input. In practice, a parser usually does not work on character
streams directly. Rather, it is prefaced by a lexer that first
converts the characters into a list of so-called
<I><FONT COLOR=maroon>tokens</FONT></I>. The separation of the lexical analysis from the
syntax analysis usually leads to a clearer design and as a benevolent
side-effect it also improves efficiency (Sec.&nbsp;<A HREF="#sec:terminal2">3.4.2</A>
shows how to combine lexing and parsing in <FONT COLOR=purple>Frown</FONT>, though).<BR>
<BR>
A simple token type is shown in Fig&nbsp;<A HREF="#fig:terminal">3.3</A>
(<TT>Terminal1.lhs</TT>). (Note that the type comprises more constructors
than initially needed.)
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Terminal</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Maybe</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>data</B>&nbsp;<I>Op</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Plus</I></TT><TT>&nbsp;|&nbsp;<I>Minus</I></TT><TT>&nbsp;|&nbsp;<I>Times</I></TT><TT>&nbsp;|&nbsp;<I>Divide</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>deriving</B>&nbsp;(<I>Show</I></TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>Op</I></TT><TT>&nbsp;-&gt;&nbsp;<I>String</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;name&nbsp;<I>Plus</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;"+"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;name&nbsp;<I>Minus</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;"-"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;name&nbsp;<I>Times</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;"*"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;name&nbsp;<I>Divide</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;"/"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;app&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>Op</I></TT><TT>&nbsp;-&gt;&nbsp;(<I>Int</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Int</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Int</I></TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;app&nbsp;<I>Plus</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;(+)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;app&nbsp;<I>Minus</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;(-)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;app&nbsp;<I>Times</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;(*)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;app&nbsp;<I>Divide</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;div</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>data</B>&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Numeral</I></TT><TT>&nbsp;<I>Int</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;<I>String</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<I>Addop</I></TT><TT>&nbsp;<I>Op</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<I>Mulop</I></TT><TT>&nbsp;<I>Op</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<I>KWLet</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<I>KWIn</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<I>Equal</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<I>LParen</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<I>RParen</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<I>EOF</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>deriving</B>&nbsp;(<I>Show</I></TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;ident,&nbsp;numeral&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Terminal</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;ident&nbsp;&nbsp;&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;fromMaybe&nbsp;(<I>Ident</I></TT><TT>&nbsp;s)&nbsp;(lookup&nbsp;s&nbsp;keywords)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;numeral&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Numeral</I></TT><TT>&nbsp;(read&nbsp;s)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;keywords&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;[(<I>String</I></TT><TT>,&nbsp;<I>Terminal</I></TT><TT>)]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;keywords&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;[&nbsp;("let",&nbsp;<I>KWLet</I></TT><TT>),&nbsp;("in",&nbsp;<I>KWIn</I></TT><TT>)&nbsp;]
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<DIV CLASS="center">Figure 3.3: <A NAME="fig:terminal"></A>The type of terminals (<TT>Terminal1.lhs</TT>).</DIV><BR>
<BR>

<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
Fig.&nbsp;<A HREF="#fig:lexer">3.4</A> (<TT>Lexer.lhs</TT>) displays a simple lexer for
arithmetic expressions, which are built from numerals using the
arithmetic operators `<TT>+</TT>', `<TT>-</TT>', `<TT>*</TT>', and `<TT>/</TT>'.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Lexer</I></TT><TT>&nbsp;&nbsp;(<B>module</B>&nbsp;<I>Terminal</I></TT><TT>,&nbsp;<B>module</B>&nbsp;<I>Lexer</I></TT><TT>)&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Char</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Terminal</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lexer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;[<I>Terminal</I></TT><TT>]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lexer&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;[]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lexer&nbsp;('+'&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Addop</I></TT><TT>&nbsp;<I>Plus</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;lexer&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lexer&nbsp;('-'&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Addop</I></TT><TT>&nbsp;<I>Minus</I></TT><TT>&nbsp;&nbsp;&nbsp;:&nbsp;lexer&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lexer&nbsp;('*'&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Mulop</I></TT><TT>&nbsp;<I>Times</I></TT><TT>&nbsp;&nbsp;&nbsp;:&nbsp;lexer&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lexer&nbsp;('/'&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Mulop</I></TT><TT>&nbsp;<I>Divide</I></TT><TT>&nbsp;&nbsp;:&nbsp;lexer&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lexer&nbsp;('='&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Equal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;lexer&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lexer&nbsp;('('&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>LParen</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;lexer&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lexer&nbsp;(')'&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>RParen</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;lexer&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lexer&nbsp;(c&nbsp;:&nbsp;cs)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;isAlpha&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<B>let</B>&nbsp;(s,&nbsp;cs')&nbsp;=&nbsp;span&nbsp;isAlphaNum&nbsp;&nbsp;cs&nbsp;&nbsp;<B>in</B>&nbsp;&nbsp;ident&nbsp;&nbsp;&nbsp;&nbsp;(c&nbsp;:&nbsp;s)&nbsp;:&nbsp;lexer&nbsp;cs'</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;isDigit&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<B>let</B>&nbsp;(s,&nbsp;cs')&nbsp;=&nbsp;span&nbsp;isDigit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs&nbsp;&nbsp;<B>in</B>&nbsp;&nbsp;numeral&nbsp;&nbsp;(c&nbsp;:&nbsp;s)&nbsp;:&nbsp;lexer&nbsp;cs'</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;otherwise&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;lexer&nbsp;cs
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<DIV CLASS="center">Figure 3.4: <A NAME="fig:lexer"></A>A simple lexer for arithmetic expressions (<TT>Lexer.lhs</TT>).</DIV><BR>
<BR>

<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
The following grammar, which builds upon the lexer, implements a
simple evaluator for arithmetic expressions (<TT>Calc.lg</TT>).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Calc</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Lexer</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Result</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;%{</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Numeral</I></TT><TT>&nbsp;{<I>Int</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Addop</I></TT><TT>&nbsp;{<I>Op</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Mulop</I></TT><TT>&nbsp;{<I>Op</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>LParen</I></TT><TT>&nbsp;&nbsp;as&nbsp;"("</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>RParen</I></TT><TT>&nbsp;&nbsp;as&nbsp;")";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Nonterminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;expr&nbsp;{<I>Int</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;term&nbsp;{<I>Int</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;factor&nbsp;{<I>Int</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;&nbsp;&nbsp;{app&nbsp;op&nbsp;v1&nbsp;v2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;expr&nbsp;{v1},&nbsp;<I>Addop</I></TT><TT>&nbsp;{op},&nbsp;term&nbsp;{v2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;term&nbsp;{e};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;term&nbsp;&nbsp;&nbsp;&nbsp;{app&nbsp;op&nbsp;v1&nbsp;v2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;term&nbsp;{v1},&nbsp;<I>Mulop</I></TT><TT>&nbsp;{op},&nbsp;factor&nbsp;{v2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;factor&nbsp;{e};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;factor&nbsp;&nbsp;{n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;<I>Numeral</I></TT><TT>&nbsp;{n};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"(",&nbsp;expr&nbsp;{e},&nbsp;")";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;}%</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;fail&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The terminal declaration now lists patterns of type <TT><I>Terminal</I></TT>. Note
that terminals may also carry semantic values. The single argument of
<TT><I>Numeral</I></TT>, for instance, records the numerical value of the numeral.<BR>
<BR>
When declaring a terminal we can optionally define a shortcut using an
<TT>as</TT>-clause as, for example, in <TT><I>LParen</I></TT><TT>&nbsp;as&nbsp;"("</TT>. The shortcut can be
used in the productions possibly improving their readability.<BR>
<BR>
Here is an example session demonstrating the evaluator.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Calc</I></TT><TT>&gt;&gt;&nbsp;lexer&nbsp;"4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1)"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;[<I>Numeral</I></TT><TT>&nbsp;4,<I>Mulop</I></TT><TT>&nbsp;<I>Times</I></TT><TT>,<I>LParen</I></TT><TT>,<I>Numeral</I></TT><TT>&nbsp;7,<I>Addop</I></TT><TT>&nbsp;<I>Plus</I></TT><TT>,<I>Numeral</I></TT><TT>&nbsp;1,<I>RParen</I></TT><TT>]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Calc</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"4711")&nbsp;::&nbsp;<I>Result</I></TT><TT>&nbsp;<I>Int</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Return</I></TT><TT>&nbsp;4711</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Calc</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1)&nbsp;-&nbsp;1")&nbsp;::&nbsp;<I>Result</I></TT><TT>&nbsp;<I>Int</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Return</I></TT><TT>&nbsp;31</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Calc</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1")&nbsp;::&nbsp;<I>Result</I></TT><TT>&nbsp;<I>Int</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Fail</I></TT><TT>&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<!--TOC subsection Monadic actions-->

<H3 CLASS="subsection"><A NAME="htoc13">3.2.4</A>&nbsp;&nbsp;Monadic actions</H3><!--SEC END -->

<A NAME="sec:monadicactions"></A>

The expression that determines the value of an attribute is usually a
pure one. It is, however, also possible to provide a monadic action
that <EM>computes</EM> the value of the attribute. The computation lives
in the underlying parsing monad. Monadic actions are enclosed in `<TT>{%&nbsp;ldots&nbsp;}</TT>' braces and have type <TT>m&nbsp;t</TT> where <TT>m</TT> is the type of the
underlying monad and <TT>t</TT> is the type of attributes.<BR>
<BR>
As an example, the following variant of the desktop calculator
(<TT>MCalc.lg</TT>) prints all intermediate results (note that we only list
the changes to the preceeding example).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;trace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;<I>Op</I></TT><TT>&nbsp;-&gt;&nbsp;(<I>Int</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Int</I></TT><TT>&nbsp;-&gt;&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Int</I></TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;trace&nbsp;op&nbsp;v1&nbsp;v2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;putStrLn&nbsp;s&nbsp;&gt;&gt;&nbsp;return&nbsp;v</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>where</B>&nbsp;v&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;app&nbsp;op&nbsp;v1&nbsp;v2</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;show&nbsp;v1&nbsp;++&nbsp;name&nbsp;op&nbsp;++&nbsp;show&nbsp;v2&nbsp;++&nbsp;"="&nbsp;++&nbsp;show&nbsp;v
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;{%&nbsp;trace&nbsp;op&nbsp;v1&nbsp;v2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;expr&nbsp;{v1},&nbsp;<I>Addop</I></TT><TT>&nbsp;{op},&nbsp;term&nbsp;{v2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;term&nbsp;{%&nbsp;trace&nbsp;op&nbsp;v1&nbsp;v2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;term&nbsp;{v1},&nbsp;<I>Mulop</I></TT><TT>&nbsp;{op},&nbsp;factor&nbsp;{v2};
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The following session illustrates its working.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>MCalc</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"4711")</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;4711</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>MCalc</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1)&nbsp;-&nbsp;1")</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;7+1=8</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;4*8=32</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;32-1=31</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;31</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>MCalc</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1")</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;7+1=8</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;Program&nbsp;error:&nbsp;user&nbsp;error&nbsp;(syntax&nbsp;error)</TT><TT>
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
In general, monadic actions are useful for performing `side-effects' (for example,
in order to parse <TT>%include</TT> directives)
and for interaction with a monadic lexer (see Sec.&nbsp;<A HREF="#sec:mlexer">3.3.1</A>).<BR>
<BR>
<!--TOC subsection Backtracking parsers-->

<H3 CLASS="subsection"><A NAME="htoc14">3.2.5</A>&nbsp;&nbsp;Backtracking parsers</H3><!--SEC END -->

<A NAME="sec:backtracking"></A>

In the previous examples we have encoded the precedences of the
operators (`<TT>*</TT>' binds more tightly than `<TT>+</TT>') into the productions
of the grammar. However, this technique soon becomes unwieldy for a
larger expression language. So let's start afresh. The grammar file
shown in Fig.&nbsp;<A HREF="#fig:let1">3.5</A> (<TT>Let1.lg</TT>) uses only a single
nonterminal for expressions (we have also extended expressions by
local definitions).
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Let</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Lexer</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Monad</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>data</B>&nbsp;<I>Expr</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Const</I></TT><TT>&nbsp;<I>Int</I></TT><TT>&nbsp;|&nbsp;<I>Var</I></TT><TT>&nbsp;<I>String</I></TT><TT>&nbsp;|&nbsp;<I>Bin</I></TT><TT>&nbsp;<I>Expr</I></TT><TT>&nbsp;<I>Op</I></TT><TT>&nbsp;<I>Expr</I></TT><TT>&nbsp;|&nbsp;<I>Let</I></TT><TT>&nbsp;<I>Decl</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>deriving</B>&nbsp;(<I>Show</I></TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>data</B>&nbsp;<I>Decl</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>String</I></TT><TT>&nbsp;:=:&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>deriving</B>&nbsp;(<I>Show</I></TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;%{</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Numeral</I></TT><TT>&nbsp;{<I>Int</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;{<I>String</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Addop</I></TT><TT>&nbsp;{<I>Op</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Mulop</I></TT><TT>&nbsp;{<I>Op</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>KWLet</I></TT><TT>&nbsp;&nbsp;&nbsp;as&nbsp;"let"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>KWIn</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"in"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Equal</I></TT><TT>&nbsp;&nbsp;&nbsp;as&nbsp;"="</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>LParen</I></TT><TT>&nbsp;&nbsp;as&nbsp;"("</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>RParen</I></TT><TT>&nbsp;&nbsp;as&nbsp;")";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;{<I>Expr</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;{<I>Const</I></TT><TT>&nbsp;n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;<I>Numeral</I></TT><TT>&nbsp;{n};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Var</I></TT><TT>&nbsp;s}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;{s};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Bin</I></TT><TT>&nbsp;e1&nbsp;op&nbsp;e2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;expr&nbsp;{e1},&nbsp;<I>Addop</I></TT><TT>&nbsp;{op},&nbsp;expr&nbsp;{e2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Bin</I></TT><TT>&nbsp;e1&nbsp;op&nbsp;e2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;expr&nbsp;{e1},&nbsp;<I>Mulop</I></TT><TT>&nbsp;{op},&nbsp;expr&nbsp;{e2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Let</I></TT><TT>&nbsp;d&nbsp;e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"let",&nbsp;decl&nbsp;{d},&nbsp;"in",&nbsp;expr&nbsp;{e};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"(",&nbsp;expr&nbsp;{e},&nbsp;")";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;decl&nbsp;&nbsp;{<I>Decl</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;decl&nbsp;&nbsp;{s&nbsp;:=:&nbsp;e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;{s},&nbsp;"=",&nbsp;expr&nbsp;{e};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;}%</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;fail&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<DIV CLASS="center">Figure 3.5: <A NAME="fig:let1"></A>An ambiguous grammar (<TT>Let1.lg</TT>).</DIV><BR>
<BR>

<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
Also note that the grammar has no <TT><I>Nonterminal</I></TT> declaration. Rather,
the terminal symbols are declared by supplying type signatures before
the respective rules. Generally, type signatures are preferable to a
<TT><I>Nonterminal</I></TT> declaration if the grammar is long.<BR>
<BR>
Of course, the rewritten grammar is no longer LALR(<I>k</I>) simply because
it is ambiguous. For instance, `<TT>1+2*3</TT>' can be parsed as <TT><I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3))</TT> or as <TT><I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2))&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3)</TT>. <FONT COLOR=purple>Frown</FONT> is also unhappy with the
grammar: it reports six shift/reduce conflicts:
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&nbsp;*&nbsp;warning:&nbsp;6&nbsp;shift/reduce&nbsp;conflicts
</TT></TD>
</TR></TABLE>
This means that <FONT COLOR=purple>Frown</FONT> wasn't able to produce a deterministic parser.
Or rather, it produced a deterministic parser by making some arbitrary
choices to avoid non-determinism (shifts are preferred to reductions,
see Sec.&nbsp;<A HREF="#sec:prec">3.2.6</A>). However, we can also instruct <FONT COLOR=purple>Frown</FONT> to
produce a non-deterministic parser, that is, one that generates all
possible parses of a given input. We do so by supplying the option
<TT>--backtrack</TT>:
<BLOCKQUOTE CLASS="quote">
<TT>frown&nbsp;--backtrack&nbsp;Let.g</TT>
</BLOCKQUOTE>
The generated parser <TT>expr</TT> now has type

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;(<I>MonadPlus</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;[<I>Terminal</I></TT><TT>]&nbsp;-&gt;&nbsp;m&nbsp;<I>Expr</I></TT><TT>&nbsp;.
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Note that the underlying monad must be an instance of <TT><I>MonadPlus</I></TT>
(defined in the standard library <TT><I>Monad</I></TT>). The list monad and the
<TT><I>Maybe</I></TT> monad are both instances of <TT><I>MonadPlus</I></TT>. The following session
shows them in action.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"1&nbsp;+&nbsp;2&nbsp;-&nbsp;3&nbsp;*&nbsp;4&nbsp;/&nbsp;5")&nbsp;::&nbsp;[<I>Expr</I></TT><TT>]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;[<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2)&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5)))),<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2)&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4))&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5))),<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2)&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)))&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5)),<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2)&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4))))&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5),<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2)&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3))&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5))),<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2)&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3))&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4))&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5)),<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2)&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3))&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)))&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5),<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2)&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3)))&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5)),<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2)&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3)))&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4))&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5),<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5))),<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4))&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5)),<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)))&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5),<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3))&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5)),<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3))&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4))&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5)]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"1&nbsp;+&nbsp;-&nbsp;3&nbsp;*&nbsp;4&nbsp;/&nbsp;5")&nbsp;::&nbsp;[<I>Expr</I></TT><TT>]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;[]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"1&nbsp;+&nbsp;2&nbsp;-&nbsp;3&nbsp;*&nbsp;4&nbsp;/&nbsp;5")&nbsp;::&nbsp;<I>Maybe</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Just</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;2)&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;3)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Divide</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;5)))))
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The list monad supports `deep backtracking': all possible parses are
returned (beware: the number grows exponentionally). The <TT><I>Maybe</I></TT> monad
implements `shallow backtracking': it commits to the first solution
(yielding the same results as the parser generated <EM>without</EM> the
option <TT>--backtrack</TT>).<BR>
<BR>
<!--TOC subsection Precedences and associativity-->

<H3 CLASS="subsection"><A NAME="htoc15">3.2.6</A>&nbsp;&nbsp;Precedences and associativity</H3><!--SEC END -->

<A NAME="sec:prec"></A>

Instead of resorting to a backtracking parser we may also help <FONT COLOR=purple>Frown</FONT> 
to generate the `right' deterministic parser by assigning
<I><FONT COLOR=maroon>precedences</FONT></I> to terminal symbols. The understand the
working of precedences it is necessary to provide some background of
the underlying parsing technique.<BR>
<BR>
LR parsers work by repeatedly performing two operations:
<I><FONT COLOR=maroon>shifts</FONT></I> and <I><FONT COLOR=maroon>reductions</FONT></I>. A shift moves a
terminal from the input onto the stack, the auxiliary data structure
maintained by the parser. A reduction replaces a top segment of the
stack matching the right-hand side of a production by its left-hand side.
Parsing succeeds if the input is empty and the stack consists of a
start symbol only. As an example, consider parsing `<TT><I>N</I></TT><TT>*<I>N</I></TT><TT>+<I>N</I></TT>'.
<DIV CLASS="center"><TABLE CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=middle><TD NOWRAP >
</TD>
<TD NOWRAP><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD ALIGN=right NOWRAP><I>N</I>*<I>N</I>+<I>N</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>shift</I></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>N</I></TD>
<TD ALIGN=right NOWRAP>*<I>N</I>+<I>N</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>reduce</I> <I>by</I> <TT><I>e</I>&nbsp;:&nbsp;</TT><TT><I> <I>N</I></I></TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I></TD>
<TD ALIGN=right NOWRAP>*<I>N</I>+<I>N</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>shift</I></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I>*</TD>
<TD ALIGN=right NOWRAP><I>N</I>+<I>N</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>shift</I></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I>*<I>N</I></TD>
<TD ALIGN=right NOWRAP>+<I>N</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>reduce</I> <I>by</I> <TT><I>e</I>&nbsp;:&nbsp;</TT><TT><I> <I>N</I></I></TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I>*<I>e</I></TD>
<TD ALIGN=right NOWRAP>+<I>N</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR></TABLE></TD>
</TR></TABLE></DIV>
At this point, there are two possibilities: we can either perform a
reduction (using the production <TT>e&nbsp;:&nbsp;e,&nbsp;*,&nbsp;e;</TT>) or shift the next
input symbol. Both choices are viable.
<DIV CLASS="center"><TABLE CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=middle><TD NOWRAP >
</TD>
<TD NOWRAP><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1>
<TR><TD ALIGN=right NOWRAP><I>e</I>*<I>e</I></TD>
<TD ALIGN=right NOWRAP>+<I>N</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>reduce</I> <I>by</I> <TT><I>e</I>&nbsp;:&nbsp;<I>e</I>,&nbsp;*,&nbsp;<I>e</I>;</TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I></TD>
<TD ALIGN=right NOWRAP>+<I>N</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>shift</I></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I>+</TD>
<TD ALIGN=right NOWRAP><I>N</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>shift</I></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I>+<I>N</I></TD>
<TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>reduce</I> <I>by</I> <TT><I>e</I>&nbsp;:&nbsp;</TT><TT><I> <I>N</I></I></TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I>+<I>e</I></TD>
<TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>reduce</I> <I>by</I> <TT><I>e</I>&nbsp;:&nbsp;<I>e</I>,&nbsp;+,&nbsp;<I>e</I>;</TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I></TD>
<TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR></TABLE></TD>
<TD NOWRAP>
&nbsp;&nbsp;&nbsp;&nbsp;
</TD>
<TD NOWRAP><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1>
<TR><TD ALIGN=right NOWRAP><I>e</I>*<I>e</I></TD>
<TD ALIGN=right NOWRAP>+<I>N</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>shift</I></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I>*<I>e</I>+</TD>
<TD ALIGN=right NOWRAP><I>N</I></TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>shift</I></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I>*<I>e</I>+<I>N</I></TD>
<TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>reduce</I> <I>by</I> <TT><I>e</I>&nbsp;:&nbsp;</TT><TT><I> <I>N</I></I></TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I>*<I>e</I>+<I>e</I></TD>
<TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>reduce</I> <I>by</I> <TT><I>e</I>&nbsp;:&nbsp;<I>e</I>,&nbsp;+,&nbsp;<I>e</I>;</TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I>*<I>e</I></TD>
<TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><I>reduce</I> <I>by</I> <TT><I>e</I>&nbsp;:&nbsp;<I>e</I>,&nbsp;*&nbsp;,&nbsp;<I>e</I>;</TT></TD>
</TR>
<TR><TD ALIGN=right NOWRAP><I>e</I></TD>
<TD ALIGN=right NOWRAP>&nbsp;</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
</TR></TABLE></TD>
</TR></TABLE></DIV>
Alas, the two choices also result in different parse trees. By default,
<FONT COLOR=purple>Frown</FONT> prefers shifts to reductions. As a consequence, <TT><I>N</I></TT><TT>*<I>N</I></TT><TT>+<I>N</I></TT> is parsed
as <TT><I>N</I></TT><TT>*(<I>N</I></TT><TT>+<I>N</I></TT><TT>)</TT>, that is, `<TT>+</TT>' binds more tightly than `<TT>*</TT>'.<BR>
<BR>
Now, we can direct the resolution of conflicts by assigning
<I><FONT COLOR=maroon>precedences</FONT></I> and <I><FONT COLOR=maroon>associativity</FONT></I> to terminal
symbols. The following declarations will do in our example (<TT>Let2.g</TT>).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;left&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;<I>Addop</I></TT><TT>&nbsp;{};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;left&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;<I>Mulop</I></TT><TT>&nbsp;{};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;nonassoc&nbsp;0&nbsp;"in";
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Thus, `<TT>*</TT>' takes precedence over `<TT>+</TT>', which in turn binds more
tightly than `<TT><B>in</B></TT>'. For instance, <TT><B>let</B>&nbsp;a&nbsp;=&nbsp;4&nbsp;<B>in</B>&nbsp;a&nbsp;+&nbsp;2</TT> is parsed as
<TT><B>let</B>&nbsp;a&nbsp;=&nbsp;4&nbsp;<B>in</B>&nbsp;(a&nbsp;+&nbsp;2)</TT>. A conflict between two symbols of equal
precedence is resolved using <I><FONT COLOR=maroon>associativity</FONT></I>: the succession
<TT>1+2+3</TT> of left-associative operators is grouped as <TT>(1+2)+3</TT>;
likewise for right-associative operators; sequences of non-associative
operators are not well-formed.<BR>
<BR>
Given the fixity declarations above <FONT COLOR=purple>Frown</FONT> now produces the `right'
deterministic parser, which can be seen in action below.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1)&nbsp;-&nbsp;1")&nbsp;::&nbsp;<I>Result</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Return</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;7)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"4&nbsp;*&nbsp;7&nbsp;+&nbsp;1&nbsp;-&nbsp;1")&nbsp;::&nbsp;<I>Result</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Return</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;7))&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1)&nbsp;-&nbsp;1\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a")&nbsp;::&nbsp;<I>Result</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Return</I></TT><TT>&nbsp;(<I>Let</I></TT><TT>&nbsp;("a"&nbsp;:=:&nbsp;<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;7)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1))&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a")&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a")))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;expr&nbsp;(lexer&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a")&nbsp;::&nbsp;<I>Result</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Fail</I></TT><TT>&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
In general, a conflict between the actions `reduce by rule <TT>r</TT>' and
`shift terminal <TT>t</TT>' is resolved as follows (the precedence of a rule
is given by the precedence of the rightmost terminal on the right-hand
side):
<DIV CLASS="center">
<TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD BGCOLOR=black COLSPAN=5><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD BGCOLOR=black COLSPAN=5><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>condition</TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>action</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP>example</TD>
</TR>
<TR><TD BGCOLOR=black COLSPAN=5><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD BGCOLOR=black COLSPAN=5><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>prec&nbsp;r&nbsp;&lt;&nbsp;prec&nbsp;t</TT></TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>shift</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP>reduce by <TT>e:e,+,e;</TT> versus shift <TT>*</TT></TD>
</TR>
<TR><TD BGCOLOR=black COLSPAN=5><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP><TT>left&nbsp;t</TT></TD>
<TD ALIGN=left NOWRAP>reduce</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP>reduce by <TT>e:e,*,e;</TT> versus shift <TT>*</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>prec&nbsp;r&nbsp;=&nbsp;prec&nbsp;t</TT></TD>
<TD ALIGN=left NOWRAP><TT>right&nbsp;t</TT></TD>
<TD ALIGN=left NOWRAP>shift</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP>reduce by <TT>e:e,++,e;</TT> versus shift <TT>++</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP><TT>nonassoc&nbsp;t</TT></TD>
<TD ALIGN=left NOWRAP>fail</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP>reduce by <TT>e:e,==,e;</TT> versus shift <TT>==</TT></TD>
</TR>
<TR><TD BGCOLOR=black COLSPAN=5><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>prec&nbsp;r&nbsp;&gt;&nbsp;prec&nbsp;t</TT></TD>
<TD ALIGN=left NOWRAP>&nbsp;</TD>
<TD ALIGN=left NOWRAP>reduce</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP>reduce by <TT>e:e,*,e;</TT> versus shift <TT>+</TT></TD>
</TR>
<TR><TD BGCOLOR=black COLSPAN=5><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD BGCOLOR=black COLSPAN=5><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR></TABLE>
</DIV><BR>
<BR>
Just in case you may wonder: there are no shift/shift conflicts by
construction; reduce/reduce conflicts cannot be cured using
precedences and associativity.<BR>
<BR>
<!--TOC subsection Multiple start symbols-->

<H3 CLASS="subsection"><A NAME="htoc16">3.2.7</A>&nbsp;&nbsp;Multiple start symbols</H3><!--SEC END -->

<A NAME="sec:multiple"></A>

A grammar may have several start symbols. In this case, <FONT COLOR=purple>Frown</FONT> 
generates multiple parsers, one for each start symbol (actually, these
are merely different entry points into the LR(0)
automaton<SUP><A NAME="text5" HREF="#note5">4</A></SUP>). We mark a symbol as a start symbol simply by putting
an asterix before its declaration (either in a <TT><I>Nonterminal</I></TT>
declaration or in a separate type signature). Consider our previous
example: most likely we want parsers both for expressions and
declarations. Thus, we write

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;*expr&nbsp;&nbsp;{<I>Expr</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;*decl&nbsp;&nbsp;{<I>Decl</I></TT><TT>};
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
and get parsers of type.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;[<I>Terminal</I></TT><TT>]&nbsp;-&gt;&nbsp;m&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;decl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;[<I>Terminal</I></TT><TT>]&nbsp;-&gt;&nbsp;m&nbsp;<I>Decl</I></TT><TT>&nbsp;.
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<!--TOC subsection Monadic attributes-->

<H3 CLASS="subsection"><A NAME="htoc17">3.2.8</A>&nbsp;&nbsp;Monadic attributes</H3><!--SEC END -->

<A NAME="sec:reader"></A>

This section does not introduce any new features of <FONT COLOR=purple>Frown</FONT> and can be
safely skipped on first reading. Its purpose is to show how to
simulate inherited attributes using a reader monad (see also
Sec.&nbsp;<A HREF="#sec:inherited">4.2</A>). Generally, inherited attributes are used to
pass context information down the parse tree. As an example, consider
implementing an evaluator for arithmetic expressions that include
variables and <TT><B>let</B></TT>-bindings (<TT>Let3.lg</TT>). To determine the value of a
variable we need to pass down an environment that records the values
of bound variables. The reader monad displayed in Fig.&nbsp;<A HREF="#fig:reader">3.6</A>
(<TT>Reader.lhs</TT>) serves exactly this purpose.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Reader</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>newtype</B>&nbsp;<I>Reader</I></TT><TT>&nbsp;env&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Reader</I></TT><TT>&nbsp;{&nbsp;apply&nbsp;::&nbsp;env&nbsp;-&gt;&nbsp;a&nbsp;}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>instance</B>&nbsp;<I>Monad</I></TT><TT>&nbsp;(<I>Reader</I></TT><TT>&nbsp;env)&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Reader</I></TT><TT>&nbsp;(\&nbsp;env&nbsp;-&gt;&nbsp;a)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;&gt;&gt;=&nbsp;k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Reader</I></TT><TT>&nbsp;(\&nbsp;env&nbsp;-&gt;&nbsp;apply&nbsp;(k&nbsp;(apply&nbsp;m&nbsp;env))&nbsp;env)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Reader</I></TT><TT>&nbsp;(error&nbsp;s)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;getenv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>Reader</I></TT><TT>&nbsp;env&nbsp;env</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;getenv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Reader</I></TT><TT>&nbsp;(\&nbsp;env&nbsp;-&gt;&nbsp;env)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;withenv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;env&nbsp;-&gt;&nbsp;<I>Reader</I></TT><TT>&nbsp;env&nbsp;a&nbsp;-&gt;&nbsp;<I>Reader</I></TT><TT>&nbsp;env'&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;withenv&nbsp;env&nbsp;m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Reader</I></TT><TT>&nbsp;(\&nbsp;env'&nbsp;-&gt;&nbsp;apply&nbsp;m&nbsp;env)
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<DIV CLASS="center">Figure 3.6: <A NAME="fig:reader"></A>The reader monad (<TT>Reader.lhs</TT>).</DIV><BR>
<BR>

<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
We need some additional helper functions for accessing and
extending environments

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>type</B>&nbsp;<I>Binding</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;(<I>String</I></TT><TT>,&nbsp;<I>Int</I></TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>type</B>&nbsp;<I>Result</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Reader</I></TT><TT>&nbsp;[<I>Binding</I></TT><TT>]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;extend&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>Binding</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Result</I></TT><TT>&nbsp;a&nbsp;-&gt;&nbsp;<I>Result</I></TT><TT>&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;extend&nbsp;b&nbsp;m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;getenv&nbsp;&gt;&gt;=&nbsp;\&nbsp;env&nbsp;-&gt;&nbsp;withenv&nbsp;(b&nbsp;:&nbsp;env)&nbsp;m</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;access&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Result</I></TT><TT>&nbsp;<I>Int</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;access&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;getenv&nbsp;&gt;&gt;=&nbsp;\&nbsp;env&nbsp;-&gt;&nbsp;return&nbsp;(fromMaybe&nbsp;0&nbsp;(lookup&nbsp;s&nbsp;env))
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The following grammar implements the desired evaluator.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;{<I>Result</I></TT><TT>&nbsp;<I>Int</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;{<B>do</B>&nbsp;{b&nbsp;&lt;-&nbsp;d;&nbsp;extend&nbsp;b&nbsp;m}}&nbsp;&nbsp;:&nbsp;&nbsp;"let",&nbsp;decl&nbsp;{d},&nbsp;"in",&nbsp;expr&nbsp;{m};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{liftM2&nbsp;(app&nbsp;op)&nbsp;m1&nbsp;m2}&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;expr&nbsp;{m1},&nbsp;<I>Addop</I></TT><TT>&nbsp;{op},&nbsp;expr&nbsp;{m2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{liftM2&nbsp;(app&nbsp;op)&nbsp;m1&nbsp;m2}&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;expr&nbsp;{m1},&nbsp;<I>Mulop</I></TT><TT>&nbsp;{op},&nbsp;expr&nbsp;{m2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{return&nbsp;n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Numeral</I></TT><TT>&nbsp;{n};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{access&nbsp;s}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;{s};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{m}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"(",&nbsp;expr&nbsp;{m},&nbsp;")";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;decl&nbsp;&nbsp;{<I>Result</I></TT><TT>&nbsp;<I>Binding</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;decl&nbsp;&nbsp;{<B>do</B>&nbsp;{v&nbsp;&lt;-&nbsp;m;&nbsp;return&nbsp;(s,v)}}&nbsp;&nbsp;:&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;{s},&nbsp;"=",&nbsp;expr&nbsp;{m};
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Note that there are two monads around: the parsing monad (in fact,
<TT>expr</TT> is parametric in this monad) and the reader monad, which is
embedded in the attributes. The parser returns a value of type <TT><I>Reader</I></TT><TT>&nbsp;<I>Int</I></TT>, to which we pass an empty initial environment.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;eval&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;[<I>Char</I></TT><TT>]&nbsp;-&gt;&nbsp;m&nbsp;<I>Int</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;eval&nbsp;inp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<B>do</B>&nbsp;{f&nbsp;&lt;-&nbsp;expr&nbsp;(lexer&nbsp;inp);&nbsp;return&nbsp;(apply&nbsp;f&nbsp;[])}</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Let's see the evaluator in action.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;eval&nbsp;"2&nbsp;+&nbsp;7"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Int</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;9</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;eval&nbsp;"a&nbsp;+&nbsp;b"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Int</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;0</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;eval&nbsp;"let&nbsp;x&nbsp;=&nbsp;4&nbsp;in&nbsp;x&nbsp;*&nbsp;x"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Int</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;16</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;eval&nbsp;"let&nbsp;x&nbsp;=&nbsp;4&nbsp;in&nbsp;x&nbsp;*&nbsp;x&nbsp;+&nbsp;x"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Int</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;20</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;eval&nbsp;"(let&nbsp;x&nbsp;=&nbsp;4&nbsp;in&nbsp;x&nbsp;*&nbsp;x)&nbsp;+&nbsp;x"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Int</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;16
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<!--TOC section Error reporting and correction-->

<H2 CLASS="section"><A NAME="htoc18">3.3</A>&nbsp;&nbsp;Error reporting and correction</H2><!--SEC END -->

<A NAME="sec:error-reporting"></A>

<!--TOC subsection Monadic lexers-->

<H3 CLASS="subsection"><A NAME="htoc19">3.3.1</A>&nbsp;&nbsp;Monadic lexers</H3><!--SEC END -->

<A NAME="sec:mlexer"></A>

The chances that parsing succeeds are probably smaller than the
chances that it fails. Good error messages are indispensable to turn
the latter into the former case. Up to now we only produced the rather
uninformative message <TT>"syntax&nbsp;error"</TT>. Fortunately, we are in a good
position to do better. LR parsing has the nice property that it
detects a syntax error at the earliest possible moment: parsing fails
as soon as the input cannot be extended to a legal sentence of the
grammar. For instance, the syntax error in <TT><B> <I>let</I></B></TT>&nbsp; <I>a</I> = 4 * (7 + 1 &minus;
1&nbsp;<TT><B> <I>in</I></B></TT>&nbsp;<I>a</I> * <I>a</I> is detected after reading the keyword `<TT><B>in</B></TT>'.<BR>
<BR>
Now, all we have to do is to keep track of context information: the
current line and column number and possibly the filename. This section
prepares the ground for maintaining state information; the parser that
actually keeps track of line numbers etc is only shown in the next
section.<BR>
<BR>
Unsurprisingly, to maintain state information we employ monads again.
This time, we require a state monad. The natural place for maintaining
information about line numbers etc is, of course, the lexer.
Consequently, we turn the stream-based lexer of type <TT><I>String</I></TT><TT>&nbsp;-&gt;&nbsp;[<I>Terminal</I></TT><TT>]</TT> into a monadic one of type

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;get&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;<I>M</I></TT><TT>&nbsp;<I>Terminal</I></TT><TT>
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
where <TT><I>M</I></TT> is the state monad. The idea is that each time <TT>get</TT> is
called it returns the next token and updates its internal state.<BR>
<BR>
The first version of the monadic lexer shown in Fig.&nbsp;<A HREF="#fig:mlexer1">3.7</A>
(<TT>MLexer1.lhs</TT>) has no internal state apart from the input stream,
that is, it provides no additional functionality compared to the
stream-based lexer.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>MLexer</I></TT><TT>&nbsp;(&nbsp;<B>module</B>&nbsp;<I>Terminal</I></TT><TT>,&nbsp;<B>module</B>&nbsp;<I>MLexer</I></TT><TT>&nbsp;)&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Terminal</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Char</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>type</B>&nbsp;<I>CPS</I></TT><TT>&nbsp;a&nbsp;answer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;(a&nbsp;-&gt;&nbsp;answer)&nbsp;-&gt;&nbsp;answer</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>newtype</B>&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;{&nbsp;unLex&nbsp;::&nbsp;forall&nbsp;ans&nbsp;.&nbsp;<I>CPS</I></TT><TT>&nbsp;a&nbsp;(<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;m&nbsp;ans)&nbsp;}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>instance</B>&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;<I>Monad</I></TT><TT>&nbsp;(<I>Lex</I></TT><TT>&nbsp;m)&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;(\&nbsp;cont&nbsp;-&gt;&nbsp;cont&nbsp;a)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;&gt;&gt;=&nbsp;k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;(\&nbsp;cont&nbsp;-&gt;&nbsp;unLex&nbsp;m&nbsp;(\&nbsp;a&nbsp;-&gt;&nbsp;unLex&nbsp;(k&nbsp;a)&nbsp;cont))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;lift&nbsp;(fail&nbsp;s)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lift&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;m&nbsp;a&nbsp;-&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lift&nbsp;m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;(\&nbsp;cont&nbsp;inp&nbsp;-&gt;&nbsp;m&nbsp;&gt;&gt;=&nbsp;\&nbsp;a&nbsp;-&gt;&nbsp;cont&nbsp;a&nbsp;inp)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;run&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;a&nbsp;-&gt;&nbsp;(<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;m&nbsp;a)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;run&nbsp;parser&nbsp;inp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;unLex&nbsp;parser&nbsp;(\&nbsp;a&nbsp;rest&nbsp;-&gt;&nbsp;return&nbsp;a)&nbsp;inp</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;get&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;<I>Terminal</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;get&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;(\&nbsp;cont&nbsp;inp&nbsp;-&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>let</B>&nbsp;lexer&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>EOF</I></TT><TT>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('+'</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>Addop</I></TT><TT>&nbsp;<I>Plus</I></TT><TT>)&nbsp;&nbsp;&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('-'</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>Addop</I></TT><TT>&nbsp;<I>Minus</I></TT><TT>)&nbsp;&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('*'</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>Mulop</I></TT><TT>&nbsp;<I>Times</I></TT><TT>)&nbsp;&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('/'</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>Mulop</I></TT><TT>&nbsp;<I>Divide</I></TT><TT>)&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('='</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>Equal</I></TT><TT>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('('</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>LParen</I></TT><TT>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;(')'</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>RParen</I></TT><TT>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;(c&nbsp;:&nbsp;cs)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;isSpace&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;lexer&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;isAlpha&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<B>let</B>&nbsp;(s,&nbsp;cs')&nbsp;=&nbsp;span&nbsp;isAlphaNum&nbsp;&nbsp;cs&nbsp;<B>in</B>&nbsp;cont&nbsp;(ident&nbsp;&nbsp;&nbsp;&nbsp;(c&nbsp;:&nbsp;s))&nbsp;cs'</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;isDigit&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<B>let</B>&nbsp;(s,&nbsp;cs')&nbsp;=&nbsp;span&nbsp;isDigit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs&nbsp;<B>in</B>&nbsp;cont&nbsp;(numeral&nbsp;&nbsp;(c&nbsp;:&nbsp;s))&nbsp;cs'</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;otherwise&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;lexer&nbsp;cs</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>in</B>&nbsp;&nbsp;lexer&nbsp;inp)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;<I>Terminal</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;(\&nbsp;cont&nbsp;inp&nbsp;-&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail&nbsp;("\n***&nbsp;syntax&nbsp;error:\n"&nbsp;++&nbsp;context&nbsp;4&nbsp;inp))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;context&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>Int</I></TT><TT>&nbsp;-&gt;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;<I>String</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;context&nbsp;n&nbsp;inp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;unlines&nbsp;(take&nbsp;n&nbsp;(lines&nbsp;inp&nbsp;++&nbsp;["&lt;end&nbsp;of&nbsp;input&gt;"]))
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<DIV CLASS="center">Figure 3.7: <A NAME="fig:mlexer1"></A>A monadic lexer for the <TT><B>let</B></TT> language (<TT>MLexer1.lhs</TT>).</DIV><BR>
<BR>

<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
Note that we use a continuation-based state monad, <TT><I>Lex</I></TT><TT>&nbsp;m</TT>, which
requires local universal quantification (a non-Haskell&nbsp;98 feature).
Actually, <TT><I>Lex</I></TT> is even a <I><FONT COLOR=maroon>monad transformer</FONT></I> so that we can
freely choose a base monad (such as <TT><I>Result</I></TT> or <TT><I>IO</I></TT>). Of course, an
`ordinary' state monad would do, as well. The monadic lexer <TT>get</TT>
incorporates more or less the stream-based lexer. We only changed the
recursive calls to lexer (ie <TT>t&nbsp;:&nbsp;lexer&nbsp;cs</TT>) into invocations of the
continuation (ie <TT>cont&nbsp;t&nbsp;cs</TT>). The error routine <TT>frown</TT> now has type

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;<I>Terminal</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;a&nbsp;,
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
that is, <TT>frown</TT> is no longer passed the remaining input but only the
look-ahead token.<BR>
<BR>
The changes to the grammar are minor: we have to declare an `end of
file' token marked by a star (<TT>Let4.lg</TT>)

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Numeral</I></TT><TT>&nbsp;{<I>Int</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;{<I>String</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Addop</I></TT><TT>&nbsp;{<I>Op</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Mulop</I></TT><TT>&nbsp;{<I>Op</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>KWLet</I></TT><TT>&nbsp;&nbsp;&nbsp;as&nbsp;"let"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>KWIn</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"in"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Equal</I></TT><TT>&nbsp;&nbsp;&nbsp;as&nbsp;"="</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>LParen</I></TT><TT>&nbsp;&nbsp;as&nbsp;"("</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>RParen</I></TT><TT>&nbsp;&nbsp;as&nbsp;")"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;*<I>EOF</I></TT><TT>;
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
and we have to provide a type signature for the generated parser (in
the Haskell section).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;<I>Expr</I></TT><TT>
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The type signature is necessary to avoid an `unresolved top-level
overloading' error (the monomorphism restriction strikes again).<BR>
<BR>
When we generate the Haskell parser we must supply the option <TT>--lexer</TT>
to inform <FONT COLOR=purple>Frown</FONT> that we use a monadic lexer.
<BLOCKQUOTE CLASS="quote">
<TT>frown&nbsp;--lexer&nbsp;Let.g</TT>
</BLOCKQUOTE>
For completeness, here is an interactive session (note that in the
case of error the look-ahead token is <EM>not</EM> displayed).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1)&nbsp;-&nbsp;1"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;7)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1)&nbsp;-&nbsp;1\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&nbsp;("a"&nbsp;:=:&nbsp;<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;7)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1))&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a")&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a"))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;Program&nbsp;error:&nbsp;user&nbsp;error&nbsp;(</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;***&nbsp;syntax&nbsp;error:</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;a&nbsp;*&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&lt;end&nbsp;of&nbsp;input&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;)</TT><TT>
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<!--TOC subsection Error reporting-->

<H3 CLASS="subsection"><A NAME="htoc20">3.3.2</A>&nbsp;&nbsp;Error reporting</H3><!--SEC END -->

<A NAME="sec:reporting"></A>

The monadic lexer shown in Fig.&nbsp;<A HREF="#fig:mlexer2">3.8</A> (<TT>MLexer2.lhs</TT>)
builds upon the one given in the previous section. The state monad
<TT><I>Lex</I></TT><TT>&nbsp;m</TT> has been extended to keep track of the current line number and
the current line itself. The current line is displayed in case of a
lexical or syntax error. As an aside, note that the column number can
be recreated from the rest of the input and the length of the current
line.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>MLexer</I></TT><TT>&nbsp;(&nbsp;<B>module</B>&nbsp;<I>Terminal</I></TT><TT>,&nbsp;<B>module</B>&nbsp;<I>MLexer</I></TT><TT>&nbsp;)&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Terminal</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Char</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>type</B>&nbsp;<I>CPS</I></TT><TT>&nbsp;a&nbsp;answer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;(a&nbsp;-&gt;&nbsp;answer)&nbsp;-&gt;&nbsp;answer</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>newtype</B>&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;{&nbsp;unLex&nbsp;::&nbsp;forall&nbsp;ans&nbsp;.&nbsp;<I>CPS</I></TT><TT>&nbsp;a&nbsp;(<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Int</I></TT><TT>&nbsp;-&gt;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;m&nbsp;ans)&nbsp;}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>instance</B>&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;<I>Monad</I></TT><TT>&nbsp;(<I>Lex</I></TT><TT>&nbsp;m)&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;(\&nbsp;cont&nbsp;-&gt;&nbsp;cont&nbsp;a)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;&gt;&gt;=&nbsp;k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;(\&nbsp;cont&nbsp;-&gt;&nbsp;unLex&nbsp;m&nbsp;(\&nbsp;a&nbsp;-&gt;&nbsp;unLex&nbsp;(k&nbsp;a)&nbsp;cont))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;lift&nbsp;(fail&nbsp;s)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lift&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;m&nbsp;a&nbsp;-&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;lift&nbsp;m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;(\&nbsp;cont&nbsp;inp&nbsp;line&nbsp;cur&nbsp;-&gt;&nbsp;m&nbsp;&gt;&gt;=&nbsp;\&nbsp;a&nbsp;-&gt;&nbsp;cont&nbsp;a&nbsp;inp&nbsp;line&nbsp;cur)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;run&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;a&nbsp;-&gt;&nbsp;(<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;m&nbsp;a)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;run&nbsp;parser&nbsp;inp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;unLex&nbsp;parser&nbsp;(\&nbsp;a&nbsp;rest&nbsp;line&nbsp;cur&nbsp;-&gt;&nbsp;return&nbsp;a)&nbsp;inp&nbsp;1&nbsp;(current&nbsp;inp)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;current&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;<I>String</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;current&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;takeWhile&nbsp;(/=&nbsp;'\n'</TT><TT>)&nbsp;s</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;get&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;<I>Terminal</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;get&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;(\&nbsp;cont&nbsp;inp&nbsp;line&nbsp;cur&nbsp;-&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;<B>let</B>&nbsp;&nbsp;lexer&nbsp;[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;x&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>EOF</I></TT><TT>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[]&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('\n'</TT><TT>&nbsp;:&nbsp;cs)&nbsp;n&nbsp;x&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;lexer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs&nbsp;(n&nbsp;+&nbsp;1)&nbsp;(current&nbsp;cs)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('+'</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;n&nbsp;x&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>Addop</I></TT><TT>&nbsp;<I>Plus</I></TT><TT>)&nbsp;&nbsp;&nbsp;cs&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('-'</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;n&nbsp;x&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>Addop</I></TT><TT>&nbsp;<I>Minus</I></TT><TT>)&nbsp;&nbsp;cs&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('*'</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;n&nbsp;x&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>Mulop</I></TT><TT>&nbsp;<I>Times</I></TT><TT>)&nbsp;&nbsp;cs&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('/'</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;n&nbsp;x&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>Mulop</I></TT><TT>&nbsp;<I>Divide</I></TT><TT>)&nbsp;cs&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('='</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;n&nbsp;x&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>Equal</I></TT><TT>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;('('</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;n&nbsp;x&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>LParen</I></TT><TT>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;(')'</TT><TT>&nbsp;&nbsp;:&nbsp;cs)&nbsp;n&nbsp;x&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;cont&nbsp;(<I>RParen</I></TT><TT>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lexer&nbsp;(c&nbsp;:&nbsp;cs)&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;isSpace&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;lexer&nbsp;cs&nbsp;n&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;isAlpha&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<B>let</B>&nbsp;(s,&nbsp;cs')&nbsp;=&nbsp;span&nbsp;isAlphaNum&nbsp;&nbsp;cs&nbsp;<B>in</B>&nbsp;cont&nbsp;(ident&nbsp;&nbsp;&nbsp;&nbsp;(c&nbsp;:&nbsp;s))&nbsp;cs'&nbsp;n&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;isDigit&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<B>let</B>&nbsp;(s,&nbsp;cs')&nbsp;=&nbsp;span&nbsp;isDigit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs&nbsp;<B>in</B>&nbsp;cont&nbsp;(numeral&nbsp;&nbsp;(c&nbsp;:&nbsp;s))&nbsp;cs'&nbsp;n&nbsp;x</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;otherwise&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;fail&nbsp;("\n***&nbsp;lexical&nbsp;error&nbsp;at&nbsp;"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++&nbsp;position&nbsp;cs&nbsp;n&nbsp;x&nbsp;++&nbsp;":\n"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++&nbsp;context&nbsp;4&nbsp;cs&nbsp;x)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;<B>in</B>&nbsp;&nbsp;lexer&nbsp;inp&nbsp;line&nbsp;cur)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;<I>Terminal</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;(\&nbsp;cont&nbsp;inp&nbsp;line&nbsp;cur&nbsp;-&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail&nbsp;("\n***&nbsp;syntax&nbsp;error&nbsp;at&nbsp;"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++&nbsp;position&nbsp;inp&nbsp;line&nbsp;cur&nbsp;++&nbsp;":\n"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++&nbsp;context&nbsp;4&nbsp;inp&nbsp;cur))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;position&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Int</I></TT><TT>&nbsp;-&gt;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;<I>String</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;position&nbsp;inp&nbsp;line&nbsp;cur&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;"(line&nbsp;"&nbsp;&nbsp;++&nbsp;show&nbsp;line&nbsp;++&nbsp;",&nbsp;column&nbsp;"&nbsp;++&nbsp;show&nbsp;col&nbsp;++&nbsp;")"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>where</B>&nbsp;col&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;length&nbsp;cur&nbsp;-&nbsp;length&nbsp;(current&nbsp;inp)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;context&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>Int</I></TT><TT>&nbsp;-&gt;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;<I>String</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;context&nbsp;n&nbsp;inp&nbsp;cur&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;unlines&nbsp;([cur,&nbsp;replicate&nbsp;col'&nbsp;'&nbsp;'</TT><TT>&nbsp;++&nbsp;"^"]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++&nbsp;take&nbsp;n&nbsp;(lines&nbsp;(drop&nbsp;1&nbsp;(dropWhile&nbsp;(/=&nbsp;'\n'</TT><TT>)&nbsp;inp))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++&nbsp;["&lt;end&nbsp;of&nbsp;input&gt;"]))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>where</B>&nbsp;col'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;length&nbsp;cur&nbsp;-&nbsp;length&nbsp;(current&nbsp;inp)&nbsp;-&nbsp;1
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<DIV CLASS="center">Figure 3.8: <A NAME="fig:mlexer2"></A>A monadic lexer for the <TT><B>let</B></TT> language featuring good error reports (<TT>MLexer2.lhs</TT>).</DIV><BR>
<BR>

<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>

The following session shows the new lexer in action.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1)&nbsp;-&nbsp;1"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;7)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1)&nbsp;-&nbsp;1\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&nbsp;("a"&nbsp;:=:&nbsp;<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;7)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1))&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a")&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a"))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;[7&nbsp;+&nbsp;1&nbsp;-&nbsp;1)\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;Program&nbsp;error:&nbsp;user&nbsp;error&nbsp;(</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;***&nbsp;lexical&nbsp;error&nbsp;at&nbsp;(line&nbsp;2,&nbsp;column&nbsp;13):</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;[7&nbsp;+&nbsp;1&nbsp;-&nbsp;1)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;in&nbsp;a&nbsp;*&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&lt;end&nbsp;of&nbsp;input&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;Program&nbsp;error:&nbsp;user&nbsp;error&nbsp;(</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;***&nbsp;syntax&nbsp;error&nbsp;at&nbsp;(line&nbsp;3,&nbsp;column&nbsp;3):</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;in&nbsp;a&nbsp;*&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;^</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&lt;end&nbsp;of&nbsp;input&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;)</TT><TT>
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
In the case of a lexical error the cursor `<TT>^</TT>' points at the
offending character. In the case of a syntax error the cursor points
at the <EM>last</EM> character of the offending token (recall that the
part of the input up to and including this token is the shortest
prefix of the input that cannot be extended to a legal sentence of the
grammar).<BR>
<BR>
<!--TOC subsection Expected tokens-->

<H3 CLASS="subsection"><A NAME="htoc21">3.3.3</A>&nbsp;&nbsp;Expected tokens</H3><!--SEC END -->

<A NAME="sec:expected"></A>

We can do even better! We can instruct <FONT COLOR=purple>Frown</FONT> to pass a list of
<I><FONT COLOR=maroon>expected</FONT></I> tokens to the error routine <TT>frown</TT> (by supplying
the option <TT>--expected</TT>).
<BLOCKQUOTE CLASS="quote">
<TT>frown&nbsp;--lexer&nbsp;--expected&nbsp;Let.g</TT>
</BLOCKQUOTE>
<FONT COLOR=purple>Frown</FONT> uses the shortcuts given in the terminal declaration for generating
lists of expected tokens. This means, in particular, that a token is
<EM>not</EM> included in such a list if it does not have a shortcut. In
our running example, we want every token to be listed. Therefore, we
add shortcuts for every terminal symbol (<TT>Let6.lg</TT>).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Numeral</I></TT><TT>&nbsp;{<I>Int</I></TT><TT>}&nbsp;&nbsp;&nbsp;as&nbsp;"&lt;numeral&gt;"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;{<I>String</I></TT><TT>}&nbsp;&nbsp;as&nbsp;"&lt;identifier&gt;"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Addop</I></TT><TT>&nbsp;{<I>Op</I></TT><TT>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"+&nbsp;or&nbsp;-"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Mulop</I></TT><TT>&nbsp;{<I>Op</I></TT><TT>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"*&nbsp;or&nbsp;/"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>KWLet</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"let"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>KWIn</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"in"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Equal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"="</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>LParen</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"("</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>RParen</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;")"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;*<I>EOF</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"&lt;end&nbsp;of&nbsp;input&gt;";
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The error routine <TT>frown</TT> now takes an additional argument of type
<TT>[<I>String</I></TT><TT>]</TT> (<TT>MLexer3.lhs</TT>).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;(<I>Monad</I></TT><TT>&nbsp;m)&nbsp;=&gt;&nbsp;[<I>String</I></TT><TT>]&nbsp;-&gt;&nbsp;<I>Terminal</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;m&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;la&nbsp;t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;(\&nbsp;cont&nbsp;inp&nbsp;line&nbsp;cur&nbsp;-&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail&nbsp;("\n***&nbsp;syntax&nbsp;error&nbsp;at&nbsp;"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++&nbsp;position&nbsp;inp&nbsp;line&nbsp;cur&nbsp;++&nbsp;":\n"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++&nbsp;context&nbsp;4&nbsp;inp&nbsp;cur</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++&nbsp;"*&nbsp;expected:&nbsp;"&nbsp;++&nbsp;concat&nbsp;(intersperse&nbsp;",&nbsp;"&nbsp;la)))
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The interactive session listed in Fig.&nbsp;<A HREF="#fig:session">3.9</A> is a bit
longer than usual to illustrate the quality of the error messages.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;[7&nbsp;+&nbsp;1&nbsp;-&nbsp;1)\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;Program&nbsp;error:&nbsp;user&nbsp;error&nbsp;(</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;***&nbsp;lexical&nbsp;error&nbsp;at&nbsp;(line&nbsp;2,&nbsp;column&nbsp;13):</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;[7&nbsp;+&nbsp;1&nbsp;-&nbsp;1)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;in&nbsp;a&nbsp;*&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&lt;end&nbsp;of&nbsp;input&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;Program&nbsp;error:&nbsp;user&nbsp;error&nbsp;(</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;***&nbsp;syntax&nbsp;error&nbsp;at&nbsp;(line&nbsp;3,&nbsp;column&nbsp;3):</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;in&nbsp;a&nbsp;*&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;^</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&lt;end&nbsp;of&nbsp;input&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;*&nbsp;expected:&nbsp;+&nbsp;or&nbsp;-,&nbsp;*&nbsp;or&nbsp;/,&nbsp;))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1)\n&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;Program&nbsp;error:&nbsp;user&nbsp;error&nbsp;(</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;***&nbsp;syntax&nbsp;error&nbsp;at&nbsp;(line&nbsp;3,&nbsp;column&nbsp;2):</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;a&nbsp;*&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;^</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&lt;end&nbsp;of&nbsp;input&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;*&nbsp;expected:&nbsp;+&nbsp;or&nbsp;-,&nbsp;*&nbsp;or&nbsp;/,&nbsp;in)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1)\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;Program&nbsp;error:&nbsp;user&nbsp;error&nbsp;(</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;***&nbsp;syntax&nbsp;error&nbsp;at&nbsp;(line&nbsp;2,&nbsp;column&nbsp;7):</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;in&nbsp;a&nbsp;*&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&lt;end&nbsp;of&nbsp;input&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;*&nbsp;expected:&nbsp;+&nbsp;or&nbsp;-,&nbsp;*&nbsp;or&nbsp;/,&nbsp;&lt;end&nbsp;of&nbsp;input&gt;)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;-&nbsp;1)\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;Program&nbsp;error:&nbsp;user&nbsp;error&nbsp;(</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;***&nbsp;syntax&nbsp;error&nbsp;at&nbsp;(line&nbsp;2,&nbsp;column&nbsp;18):</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;-&nbsp;1)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;in&nbsp;a&nbsp;*&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&lt;end&nbsp;of&nbsp;input&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;*&nbsp;expected:&nbsp;&lt;numeral&gt;,&nbsp;&lt;identifier&gt;,&nbsp;let,&nbsp;()</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1)\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;Program&nbsp;error:&nbsp;user&nbsp;error&nbsp;(</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;***&nbsp;syntax&nbsp;error&nbsp;at&nbsp;(line&nbsp;2,&nbsp;column&nbsp;12):</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;in&nbsp;a&nbsp;*&nbsp;a</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&lt;end&nbsp;of&nbsp;input&gt;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;*&nbsp;expected:&nbsp;+&nbsp;or&nbsp;-,&nbsp;*&nbsp;or&nbsp;/,&nbsp;in)</TT><TT>
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<DIV CLASS="center">Figure 3.9: <A NAME="fig:session"></A>A session full of syntax errors.</DIV><BR>
<BR>

<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
<!--TOC subsection Error correction-->

<H3 CLASS="subsection"><A NAME="htoc22">3.3.4</A>&nbsp;&nbsp;Error correction</H3><!--SEC END -->

<A NAME="sec:errorcorrection"></A>

So far we have content ourselves with reporting syntax errors. To a
limited extent it is also possible to <I><FONT COLOR=maroon>correct</FONT></I> errors.
Consider the last rule of the following grammar (<TT>Let7.lg</TT>).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;{<I>Expr</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;{<I>Const</I></TT><TT>&nbsp;n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;<I>Numeral</I></TT><TT>&nbsp;{n};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Var</I></TT><TT>&nbsp;s}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;{s};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Bin</I></TT><TT>&nbsp;e1&nbsp;op&nbsp;e2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;expr&nbsp;{e1},&nbsp;<I>Addop</I></TT><TT>&nbsp;{op},&nbsp;expr&nbsp;{e2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Bin</I></TT><TT>&nbsp;e1&nbsp;op&nbsp;e2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;expr&nbsp;{e1},&nbsp;<I>Mulop</I></TT><TT>&nbsp;{op},&nbsp;expr&nbsp;{e2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Let</I></TT><TT>&nbsp;d&nbsp;e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"let",&nbsp;decl&nbsp;{d},&nbsp;"in",&nbsp;expr&nbsp;{e};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"(",&nbsp;expr&nbsp;{e},&nbsp;")";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"(",&nbsp;expr&nbsp;{e},&nbsp;insert&nbsp;")";
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The symbol <TT>insert&nbsp;")"</TT> instructs <FONT COLOR=purple>Frown</FONT> to automatically insert a
<TT>")"</TT> token <EM>if parsing would otherwise fail</EM>. The special symbol
<TT>insert&nbsp;")"</TT> can be seen as being defined by the &#1108;-production
<TT>insert&nbsp;")"&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;;</TT>. The difference to an `ordinary'
user-defined &#1108;-production is that the rule is only applied if
every other action would fail.<BR>
<BR>
The following session shows the error correction in action.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1)&nbsp;-&nbsp;1"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;7)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1)&nbsp;-&nbsp;1\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&nbsp;("a"&nbsp;:=:&nbsp;<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;7)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1))&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a")&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a"))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&nbsp;("a"&nbsp;:=:&nbsp;<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;7)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)))&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a")&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a"))
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
In the last query the missing parenthesis `)' is inserted just
before the keyword `<TT><B>in</B></TT>'. This may or may not what the user intended!<BR>
<BR>
It is generally a good idea to notify the user if a token is inserted.
This is relatively easy to accomplish using monadic actions
(<TT>Let8.lg</TT>). The parsing monad is now <TT><I>Lex</I></TT><TT>&nbsp;<I>IO</I></TT>; the monad transformer
<TT><I>Lex</I></TT> proves its worth.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>Lex</I></TT><TT>&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT><TT>
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;{<I>Expr</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;{<I>Const</I></TT><TT>&nbsp;n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;<I>Numeral</I></TT><TT>&nbsp;{n};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Var</I></TT><TT>&nbsp;s}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;{s};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Bin</I></TT><TT>&nbsp;e1&nbsp;op&nbsp;e2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;expr&nbsp;{e1},&nbsp;<I>Addop</I></TT><TT>&nbsp;{op},&nbsp;expr&nbsp;{e2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Bin</I></TT><TT>&nbsp;e1&nbsp;op&nbsp;e2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;expr&nbsp;{e1},&nbsp;<I>Mulop</I></TT><TT>&nbsp;{op},&nbsp;expr&nbsp;{e2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Let</I></TT><TT>&nbsp;d&nbsp;e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;"let",&nbsp;decl&nbsp;{d},&nbsp;"in",&nbsp;expr&nbsp;{e};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;"(",&nbsp;expr&nbsp;{e},&nbsp;close&nbsp;{_};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;close&nbsp;&nbsp;{()};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;close&nbsp;&nbsp;{()}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;")";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{%&nbsp;insert&nbsp;")"}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;insert&nbsp;")";
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;insert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Lex</I></TT><TT>&nbsp;<I>IO</I></TT><TT>&nbsp;()</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;insert&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;lift&nbsp;(putStrLn&nbsp;("Warning:&nbsp;"&nbsp;++&nbsp;s&nbsp;++&nbsp;"&nbsp;inserted"))
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Let's repeat the last query of the previous session.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&gt;&gt;&nbsp;run&nbsp;expr&nbsp;"let\n&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;4&nbsp;*&nbsp;(7&nbsp;+&nbsp;1&nbsp;-&nbsp;1\n&nbsp;in&nbsp;a&nbsp;*&nbsp;a"&nbsp;::&nbsp;<I>IO</I></TT><TT>&nbsp;<I>Expr</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;Warning:&nbsp;)&nbsp;inserted</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Let</I></TT><TT>&nbsp;("a"&nbsp;:=:&nbsp;<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;4)&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;7)&nbsp;<I>Plus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1))&nbsp;<I>Minus</I></TT><TT>&nbsp;(<I>Const</I></TT><TT>&nbsp;1)))&nbsp;(<I>Bin</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a")&nbsp;<I>Times</I></TT><TT>&nbsp;(<I>Var</I></TT><TT>&nbsp;"a"))
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The reader is invited to extend the code so that the current source
location is additionally printed (informing the user <EM>where</EM> the
token has been inserted).<BR>
<BR>
<!--TOC section Advanced features-->

<H2 CLASS="section"><A NAME="htoc23">3.4</A>&nbsp;&nbsp;Advanced features</H2><!--SEC END -->


<!--TOC subsection Rule schemes-->

<H3 CLASS="subsection"><A NAME="htoc24">3.4.1</A>&nbsp;&nbsp;Rule schemes</H3><!--SEC END -->


When we define grammars we often find ourselves repeatedly writing
similar rules. A common pattern is the <I><FONT COLOR=maroon>repetition</FONT></I> of
symbols. As an example, the following rules define a repetition of <TT>t</TT>
symbols.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;ts,&nbsp;t;
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
As an aside, note that the second rule is intentionally
<I><FONT COLOR=maroon>left-recursive</FONT></I>. LR parsers prefer left to right
recursion: the rules above use constant stack space whereas the
right-recursive variant requires space linear in the length of the
input.<BR>
<BR>
Now, <FONT COLOR=purple>Frown</FONT> allows to capture recurring patterns using so-called
<I><FONT COLOR=maroon>rule schemes</FONT></I>. Here is the scheme for a repetition of
symbols (of arity <TT>0</TT>).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;many&nbsp;x,&nbsp;x;
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
The first line contains <TT>many</TT>'s type signature: it simply says that
neither <TT>many</TT> nor <TT>many</TT>'s argument <TT>x</TT> possess attributes. Given
this scheme we can simply write <TT>many&nbsp;t</TT> for a repetition of <TT>t</TT>
symbols.<BR>
<BR>
The rule for repetition becomes more interesting if the argument
possesses an attribute (is of arity&nbsp;<TT>1</TT>). In this case, <TT>many</TT>
returns a list of semantic values.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many&nbsp;x&nbsp;{[a]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x&nbsp;{a};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many&nbsp;x&nbsp;{[]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many&nbsp;x&nbsp;{as&nbsp;++&nbsp;[a]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;many&nbsp;as&nbsp;{as};&nbsp;x&nbsp;{a};
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
(The use of list concatenation `<TT>++</TT>' in the second rule incurs a
runtime penalty which we will cure later.) The first line contains
again the type signature, which we may read as a conditional clause:
if <TT>x</TT> has one attribute of type <TT>a</TT>, then <TT>many&nbsp;x</TT> has one attribute
of type <TT>[a]</TT>. This schemes comes in handy if we extend our little
expression language by applications and abstractions (we assume that
the abstract syntax has been extended suitably; <TT>aexpr</TT> denotes atomic
expressions).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;{<I>App</I></TT><TT>&nbsp;e&nbsp;es}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;aexpr&nbsp;{e},&nbsp;many&nbsp;aexpr&nbsp;{es};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;{<I>Abs</I></TT><TT>&nbsp;(i&nbsp;:&nbsp;is)&nbsp;e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;"\\",&nbsp;<I>Ident</I></TT><TT>&nbsp;{i},&nbsp;many&nbsp;(<I>Ident</I></TT><TT>&nbsp;{})&nbsp;{is},&nbsp;".",&nbsp;expr&nbsp;{e};
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Note that if we pass terminal symbols as arguments to rule schemes
they must be written with (empty) curly braces&mdash;<FONT COLOR=purple>Frown</FONT> can only
identify terminal symbols, ie patterns, if they have exactly the same
syntactic form as in the terminal declaration. Think of `<TT>{}</TT>' as a
placeholder.<BR>
<BR>
In the above definition of <TT>many</TT> we have used list concatenation to
append an element to a list. The following improved definition does
away with this linear-time operation employing Hughes' efficient
sequence type [<A HREF="#Hug86Nov"><CITE>3</CITE></A>].

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many&nbsp;x&nbsp;&nbsp;{[a]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x&nbsp;{a};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many&nbsp;x&nbsp;&nbsp;{s&nbsp;[]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;many'&nbsp;x&nbsp;{s};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many'&nbsp;x&nbsp;&nbsp;{[a]&nbsp;-&gt;&nbsp;[a]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x&nbsp;{a};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many'&nbsp;x&nbsp;&nbsp;{\&nbsp;as&nbsp;-&gt;&nbsp;as}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\&nbsp;as&nbsp;-&gt;&nbsp;s&nbsp;(a&nbsp;:&nbsp;as)}&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;many'&nbsp;x&nbsp;{s},&nbsp;x&nbsp;{a};
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
These schemata are predefined in <FONT COLOR=purple>Frown</FONT>. There is a caveat, however:
the singleton production <TT>many&nbsp;x&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;many'&nbsp;x</TT> may
introduce a shift/reduce conflict, see Sec.&nbsp;<A HREF="#sec:conflicts">4.3</A>.<BR>
<BR>
Actually, both the <TT>many</TT> scheme with no attributes and the scheme
above with one attribute are predefined. In general, it is possible to
use the same name for schemes and nonterminals of different arity. The
only restriction is that the arity of the scheme must determine the
arity of its arguments.<BR>
<BR>
Another useful variation of <TT>many</TT> is <TT>sepBy&nbsp;x&nbsp;sep</TT> which denotes a
list of <TT>x</TT> symbols separated by <TT>sep</TT> symbols (<TT>sepBy</TT> and <TT>sepBy1</TT>
are predefined, as well).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;sepBy&nbsp;x&nbsp;sep&nbsp;&nbsp;{[a]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x&nbsp;{a},&nbsp;sep;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;sepBy&nbsp;x&nbsp;sep&nbsp;&nbsp;{[]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{as}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;sepBy1&nbsp;x&nbsp;sep&nbsp;{as};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;sepBy1&nbsp;x&nbsp;sep&nbsp;&nbsp;{[a]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x&nbsp;{a},&nbsp;sep;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;sepBy1&nbsp;x&nbsp;sep&nbsp;&nbsp;{[a]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;x&nbsp;{a};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{as&nbsp;++&nbsp;[a]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;sepBy1&nbsp;x&nbsp;sep&nbsp;{as},&nbsp;sep,&nbsp;x&nbsp;{a};
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
This scheme is useful for adding tuples to our expression language.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;{<I>Tuple</I></TT><TT>&nbsp;es}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;"(",&nbsp;sepBy&nbsp;expr&nbsp;","&nbsp;{es},&nbsp;")";
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
For a complete list of predefined schemes see
Sec.&nbsp;<A HREF="#sec:stdenv">5.3</A>.<BR>
<BR>
<!--TOC subsection A second look at terminal symbols-->

<H3 CLASS="subsection"><A NAME="htoc25">3.4.2</A>&nbsp;&nbsp;A second look at terminal symbols</H3><!--SEC END -->

<A NAME="sec:terminal2"></A>

The terminal symbols of a grammar are given by Haskell
<I><FONT COLOR=maroon>patterns</FONT></I>. Up to now we have seen only simple
patterns. Patterns, however, may also be nested or even
overlapping. In the latter case, one should be careful to list
specific patterns before general ones in a <TT><I>Terminal</I></TT> declaration
(<FONT COLOR=purple>Frown</FONT> preserves the relative ordering of patterns when generating
<TT><B>case</B></TT> expressions). Here is a simple example.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;"if"&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;"if"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;"then"&nbsp;&nbsp;as&nbsp;"then"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;"else"&nbsp;&nbsp;as&nbsp;"else"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Ident</I></TT><TT>&nbsp;{<I>String</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;ldots
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Note that keywords are declared just by listing them before the
general pattern for identifiers.<BR>
<BR>
Alternatively, terminal symbols can be specifed using so-called
<I><FONT COLOR=maroon>guards</FONT></I>, Boolean functions of type <TT><I>Terminal</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Bool</I></TT>.
Guards are most useful for defining character classes as in the
following example.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;guard&nbsp;{&nbsp;isAlpha&nbsp;}&nbsp;as&nbsp;"alpha"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;ldots
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
A guard is introduced by the keyword <TT>guard</TT>, followed by its Haskell
definition, followed by the mandatory shortcut. The shortcut can then
be used as a terminal symbol <EM>of arity&nbsp;<TT>1</TT></EM>: its attribute of
type <TT><I>Terminal</I></TT> is the very input symbol that matched the guard.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;ident&nbsp;{<I>String</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;ident&nbsp;{c&nbsp;:&nbsp;cs}&nbsp;&nbsp;:&nbsp;&nbsp;"alpha"&nbsp;{c},&nbsp;many&nbsp;"alpha"&nbsp;{cs};
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
Using guards one can quite easily define character-based grammars that
include lexical syntax (that is, whose parsers combine lexing and
parsing). Fig.&nbsp;<A HREF="#fig:varcalc">3.10</A> lists a variant of the desktop
calculator that works without a separate lexer.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Calc</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Result</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Char</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>type</B>&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Char</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;%{</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;guard&nbsp;{isDigit}&nbsp;&nbsp;as&nbsp;"digit"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;'+'</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;'*'</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;'('</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;')'</TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Nonterminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;expr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Integer</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;term&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Integer</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;factor&nbsp;&nbsp;&nbsp;{<I>Integer</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;numeral&nbsp;&nbsp;{<I>Integer</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{v1&nbsp;+&nbsp;v2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;expr&nbsp;{v1},&nbsp;&nbsp;'+'</TT><TT>,&nbsp;&nbsp;term&nbsp;{v2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;term&nbsp;{e};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;term&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{v1&nbsp;*&nbsp;v2}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;term&nbsp;{v1},&nbsp;&nbsp;'*'</TT><TT>,&nbsp;&nbsp;factor&nbsp;{v2};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;factor&nbsp;{e};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;factor&nbsp;&nbsp;&nbsp;{n}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;numeral&nbsp;{n};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{e}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;'('</TT><TT>,&nbsp;expr&nbsp;{e},&nbsp;')'</TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;numeral&nbsp;&nbsp;{encode&nbsp;c}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;"digit"&nbsp;{c};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{n&nbsp;*&nbsp;10&nbsp;+&nbsp;encode&nbsp;c}&nbsp;&nbsp;|&nbsp;&nbsp;numeral&nbsp;{n},&nbsp;"digit"&nbsp;{c};&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;}%</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;encode&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;toInteger&nbsp;(fromEnum&nbsp;&nbsp;c&nbsp;-&nbsp;fromEnum&nbsp;'0'</TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;fail&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<DIV CLASS="center">Figure 3.10: <A NAME="fig:varcalc"></A>A variant of the desktop calculator that includes
lexical syntax (<TT>VarCalc.lhs</TT>).</DIV><BR>
<BR>

<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
Note that the type <TT><I>Terminal</I></TT> must be defined in the Haskell section.
The reader may wish to extend the grammar so that two tokens can be
separated by white space.<BR>
<BR>
<!--TOC subsection Look-ahead-->

<H3 CLASS="subsection"><A NAME="htoc26">3.4.3</A>&nbsp;&nbsp;Look-ahead</H3><!--SEC END -->

<A NAME="sec:look-ahead"></A>

&lang;<B>To do:</B>&nbsp;type grammar.&rang;<BR>
<BR>
<!--TOC subsection Debugging and tracing-->

<H3 CLASS="subsection"><A NAME="htoc27">3.4.4</A>&nbsp;&nbsp;Debugging and tracing</H3><!--SEC END -->

<A NAME="sec:tracing"></A>

&lang;<B>To do:</B>&nbsp;<TT>--prefix</TT> und <TT>--suffix</TT>.&rang;<BR>
<BR>
&lang;<B>To do:</B>&nbsp;<TT>--debug</TT> und <TT>--pagewidth</TT>.&rang;<BR>
<BR>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Paren</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;%{</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;'('</TT><TT>&nbsp;|&nbsp;')'</TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;{<I>IO</I></TT><TT>&nbsp;()};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;{reduce&nbsp;"p&nbsp;:&nbsp;;"}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;{<B>do</B>&nbsp;t1;&nbsp;shift&nbsp;'('</TT><TT>;&nbsp;t2;&nbsp;shift&nbsp;')'</TT><TT>;&nbsp;reduce&nbsp;"p&nbsp;:&nbsp;p,&nbsp;'(',&nbsp;p,&nbsp;')';"}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;paren&nbsp;{t1},&nbsp;'('</TT><TT>,&nbsp;paren&nbsp;{t2},&nbsp;')'</TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;}%</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;fail&nbsp;"***&nbsp;syntax&nbsp;error"</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;shift&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>Char</I></TT><TT>&nbsp;-&gt;&nbsp;<I>IO</I></TT><TT>&nbsp;()</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;shift&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;putStrLn&nbsp;("shift&nbsp;"&nbsp;++&nbsp;show&nbsp;c)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;reduce&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>String</I></TT><TT>&nbsp;-&gt;&nbsp;<I>IO</I></TT><TT>&nbsp;()</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;reduce&nbsp;p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;putStrLn&nbsp;("reduce&nbsp;by&nbsp;"&nbsp;++&nbsp;p)
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<!--TOC subsection Output formats and optimizations-->

<H3 CLASS="subsection"><A NAME="htoc28">3.4.5</A>&nbsp;&nbsp;Output formats and optimizations</H3><!--SEC END -->

<A NAME="sec:optimizations"></A>

&lang;<B>To do:</B>&nbsp;optimizations (<TT>--optimize</TT>).&rang;<BR>
<BR>
&lang;<B>To do:</B>&nbsp;which format benefits from GHC extensions (<TT>--ghc</TT>)?&rang;<BR>
<BR>
&lang;<B>To do:</B>&nbsp;<TT>NOINLINE</TT> pragmas (<TT>--noinline</TT>).&rang;<BR>
<BR>
&lang;<B>To do:</B>&nbsp;<TT>--signature</TT>.&rang;<BR>
<BR>
<!--BEGIN NOTES chapter-->
<HR WIDTH="50%" SIZE=1><DL CLASS="list"><DT CLASS="dt-list"><A NAME="note2" HREF="#text2"><FONT SIZE=5>1</FONT></A><DD CLASS="dd-list">In fact, we can use the same notation, the
 so-called <I><FONT COLOR=maroon><TT><B>do</B></TT>-notation</FONT></I>, for different monads (cf
 Haskell Report §3.14).
<DT CLASS="dt-list"><A NAME="note3" HREF="#text3"><FONT SIZE=5>2</FONT></A><DD CLASS="dd-list">The source files of the examples are
located in the directory <TT>Manual/Examples</TT>.
<DT CLASS="dt-list"><A NAME="note4" HREF="#text4"><FONT SIZE=5>3</FONT></A><DD CLASS="dd-list">Actually, the file is
 generated using <TT>frown&nbsp;--suffix&nbsp;Paren.g</TT>, see
 Sec.&nbsp;<A HREF="#sec:options">5.5</A>.
<DT CLASS="dt-list"><A NAME="note5" HREF="#text5"><FONT SIZE=5>4</FONT></A><DD CLASS="dd-list">There is, however, a small cost involved: for each start
 symbol <TT>s</TT> <FONT COLOR=purple>Frown</FONT> silently introduces a new symbol <TT>s'</TT> and a new
 rule <TT>s'&nbsp;:&nbsp;s,&nbsp;<I>EOF</I></TT>. This increases the size of the automaton by a
 few states.
</DL>
<!--END NOTES-->
<!--TOC chapter Tips and tricks-->

<H1 CLASS="chapter"><A NAME="htoc29">Chapter&nbsp;4</A>&nbsp;&nbsp;Tips and tricks</H1><!--SEC END -->


<!--TOC section Irrefutable patterns-->

<H2 CLASS="section"><A NAME="htoc30">4.1</A>&nbsp;&nbsp;Irrefutable patterns</H2><!--SEC END -->

<A NAME="sec:irrefutable"></A>

Irrefutable patterns on the RHS (<TT>VarParen.lg</TT>):

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>VarParen</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Result</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>newtype</B>&nbsp;<I>Tree</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Node</I></TT><TT>&nbsp;[<I>Tree</I></TT><TT>]</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>deriving</B>&nbsp;(<I>Show</I></TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;%{</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;'('</TT><TT>&nbsp;|&nbsp;')'</TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Nonterminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;paren&nbsp;{<I>Tree</I></TT><TT>};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;&nbsp;{<I>Node</I></TT><TT>&nbsp;[]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Node</I></TT><TT>&nbsp;(x&nbsp;:&nbsp;xs)}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;paren&nbsp;{x},&nbsp;'('</TT><TT>,&nbsp;paren&nbsp;{<I>Node</I></TT><TT>&nbsp;xs},&nbsp;')'</TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;}%</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;fail&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<!--TOC section Inherited attributes-->

<H2 CLASS="section"><A NAME="htoc31">4.2</A>&nbsp;&nbsp;Inherited attributes</H2><!--SEC END -->

<A NAME="sec:inherited"></A>

Shows how to simulate inherited attributes: <TT>expr</TT> has type <TT><I>Integer</I></TT><TT>&nbsp;-&gt;&nbsp;(<I>Tree</I></TT><TT>&nbsp;<I>Integer</I></TT><TT>,&nbsp;<I>Integer</I></TT><TT>)</TT>, it takes the global minimum to the
rep-min tree (with all elements replaced by the minimum) and the local
minimum (<TT>RepMin.lg</TT>).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>RepMin</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>data</B>&nbsp;<I>Tree</I></TT><TT>&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Leaf</I></TT><TT>&nbsp;a&nbsp;|&nbsp;<I>Fork</I></TT><TT>&nbsp;(<I>Tree</I></TT><TT>&nbsp;a)&nbsp;(<I>Tree</I></TT><TT>&nbsp;a)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>deriving</B>&nbsp;(<I>Show</I></TT><TT>)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>data</B>&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;=&nbsp;&nbsp;<I>Num</I></TT><TT>&nbsp;<I>Integer</I></TT><TT>&nbsp;|&nbsp;<I>LPar</I></TT><TT>&nbsp;|&nbsp;<I>RPar</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;%{</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Terminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Num</I></TT><TT>&nbsp;{<I>Integer</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>LPar</I></TT><TT>&nbsp;&nbsp;as&nbsp;"("</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>RPar</I></TT><TT>&nbsp;&nbsp;as&nbsp;")";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<I>Nonterminal</I></TT><TT>&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;*&nbsp;&nbsp;start&nbsp;&nbsp;{<I>Tree</I></TT><TT>&nbsp;<I>Integer</I></TT><TT>}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expr&nbsp;&nbsp;&nbsp;{<I>Integer</I></TT><TT>&nbsp;-&gt;&nbsp;(<I>Tree</I></TT><TT>&nbsp;<I>Integer</I></TT><TT>,&nbsp;<I>Integer</I></TT><TT>)};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;start&nbsp;{&nbsp;<B>let</B>&nbsp;(t,&nbsp;m)&nbsp;=&nbsp;f&nbsp;m&nbsp;<B>in</B>&nbsp;t&nbsp;}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;expr&nbsp;{f};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;{&nbsp;\&nbsp;m&nbsp;-&gt;&nbsp;(<I>Leaf</I></TT><TT>&nbsp;m,&nbsp;i)&nbsp;}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;<I>Num</I></TT><TT>&nbsp;{i};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;{&nbsp;\&nbsp;m&nbsp;-&gt;&nbsp;<B>let</B>&nbsp;&nbsp;{&nbsp;(tl,&nbsp;ml)&nbsp;&nbsp;=&nbsp;&nbsp;l&nbsp;m</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;(tr,&nbsp;mr)&nbsp;&nbsp;=&nbsp;&nbsp;r&nbsp;m&nbsp;}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>in</B>&nbsp;(<I>Fork</I></TT><TT>&nbsp;tl&nbsp;tr,&nbsp;ml&nbsp;`min`&nbsp;mr)&nbsp;}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;expr&nbsp;{l},&nbsp;"(",&nbsp;expr&nbsp;{r},&nbsp;")";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;}%</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;fail&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
!avoid layout-sensitive code!<BR>
<BR>
<!--TOC section Dealing with conflicts-->

<H2 CLASS="section"><A NAME="htoc32">4.3</A>&nbsp;&nbsp;Dealing with conflicts</H2><!--SEC END -->

<A NAME="sec:conflicts"></A>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many'&nbsp;x&nbsp;:&nbsp;many&nbsp;x;
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<!--TOC section Multiple attributes-->

<H2 CLASS="section"><A NAME="htoc33">4.4</A>&nbsp;&nbsp;Multiple attributes</H2><!--SEC END -->

<A NAME="sec:multattr"></A>

<!--TOC chapter Reference manual-->

<H1 CLASS="chapter"><A NAME="htoc34">Chapter&nbsp;5</A>&nbsp;&nbsp;Reference manual</H1><!--SEC END -->


<!--TOC section Lexical syntax of <FONT COLOR=purple>Frown</FONT>-->

<H2 CLASS="section"><A NAME="htoc35">5.1</A>&nbsp;&nbsp;Lexical syntax of <FONT COLOR=purple>Frown</FONT></H2><!--SEC END -->


&lang;<B>To do:</B>&nbsp;that of Haskell including comments.&rang;<BR>
<BR>
&lang;<B>To do:</B>&nbsp;Literate grammar file (Bird tracks)&rang;.<BR>
<BR>
<!--TOC section Syntax of <FONT COLOR=purple>Frown</FONT>-->

<H2 CLASS="section"><A NAME="htoc36">5.2</A>&nbsp;&nbsp;Syntax of <FONT COLOR=purple>Frown</FONT></H2><!--SEC END -->


Grammar file.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;many&nbsp;"not&nbsp;special",</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"%{",</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;many&nbsp;decl;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"}%",</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;many&nbsp;"not&nbsp;special";
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Note that <TT>"not&nbsp;special"</TT> matches every token except the special curly
braces <TT>"%{"</TT> and <TT>"}%"</TT>.<BR>
<BR>
Declaration.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;decl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;terminals;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;nonterminals;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;fixity;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;signature;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;productions;
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Terminal declaration.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;terminals&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;"Terminal",&nbsp;"=",&nbsp;sepBy&nbsp;term&nbsp;"|",&nbsp;";";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;term&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;opt&nbsp;"*",&nbsp;assoc,&nbsp;terminal;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;opt&nbsp;"*",&nbsp;assoc,&nbsp;literal,&nbsp;"=",&nbsp;terminal;&nbsp;</TT>-- deprecated</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;opt&nbsp;"*",&nbsp;assoc,&nbsp;terminal,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"as",&nbsp;literal;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;opt&nbsp;"*",&nbsp;assoc,&nbsp;"guard",&nbsp;haskell,&nbsp;&nbsp;"as",&nbsp;literal;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;assoc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"left",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Numeral</I></TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"right",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Numeral</I></TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"nonassoc",&nbsp;&nbsp;<I>Numeral</I></TT><TT>;
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Nonterminal declaration.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;nonterminals&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;"Nonterminal",&nbsp;"=",&nbsp;sepBy&nbsp;nonterm&nbsp;"|",&nbsp;";";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;nonterm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;opt&nbsp;"*",&nbsp;nonterminal;
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Fixity declaration.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;fixity&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;"left",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Numeral</I></TT><TT>,&nbsp;terminal,&nbsp;";";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;"right",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Numeral</I></TT><TT>,&nbsp;terminal,&nbsp;";";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;"nonassoc",&nbsp;&nbsp;<I>Numeral</I></TT><TT>,&nbsp;terminal,&nbsp;";";
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Type signature.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;signature&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;"::",&nbsp;nonterminal,&nbsp;premise,&nbsp;";";&nbsp;&nbsp;</TT>-- deprecated</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;nonterminal,&nbsp;premise,&nbsp;";";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"::",&nbsp;"*",&nbsp;nonterminal,&nbsp;";";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>-- deprecated</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"*",&nbsp;nonterminal,&nbsp;";";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;premise&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"&lt;-",&nbsp;sepBy1&nbsp;nonterminal&nbsp;",";
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Productions.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;productions&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;nonterminal,&nbsp;":",&nbsp;sepBy&nbsp;symbol&nbsp;",",&nbsp;";",&nbsp;alts;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;alts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;attributes,&nbsp;"|",&nbsp;sepBy&nbsp;symbol&nbsp;",",&nbsp;";",&nbsp;alts;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;symbol&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;"insert",&nbsp;&nbsp;terminal;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"delete",&nbsp;&nbsp;terminal;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"prec",&nbsp;&nbsp;&nbsp;&nbsp;terminal;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;terminal;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;nonterminal;
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Nonterminal symbols (<TT>expr0</TT> is a variant of <TT>expr</TT> lacking the
embedded Haskell production).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;nonterminal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;expr0,&nbsp;attributes;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;<I>Varid</I></TT><TT>,&nbsp;many&nbsp;aexpr0;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;aexpr0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;<I>Varid</I></TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Conid</I></TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;literal;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"(",&nbsp;sepBy&nbsp;expr&nbsp;",",&nbsp;")";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"[",&nbsp;sepBy&nbsp;expr&nbsp;",",&nbsp;"]";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;expr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;aexpr;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Varid</I></TT><TT>,&nbsp;many1&nbsp;aexpr;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Conid</I></TT><TT>,&nbsp;many1&nbsp;aexpr;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;aexpr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;<I>Varid</I></TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Conid</I></TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;literal;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"(",&nbsp;sepBy&nbsp;expr&nbsp;",",&nbsp;")";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"[",&nbsp;sepBy&nbsp;expr&nbsp;",",&nbsp;"]";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;haskell;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>-- embedded Haskell<TT>
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Terminal symbols.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;terminal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;pat;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;literal,&nbsp;haskell,&nbsp;attributes;&nbsp;&nbsp;</TT>-- shortcut</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;pat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;apat;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Conid</I></TT><TT>,&nbsp;many1&nbsp;apat;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;apat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;<I>Conid</I></TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;literal;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>-- either literal or shortcut</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"(",&nbsp;sepBy&nbsp;pat&nbsp;",",&nbsp;")";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"[",&nbsp;sepBy&nbsp;pat&nbsp;",",&nbsp;"]";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;haskell;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;literal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;<I>String</I></TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Numeral</I></TT><TT>;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<I>Char</I></TT><TT>;
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Embedded Haskell (types, patterns, and expressions).

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;attributes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;haskell,&nbsp;attributes;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;haskell&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;"{",&nbsp;many&nbsp;hs,&nbsp;"}";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;hs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;"not&nbsp;brace";</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;"{",&nbsp;many&nbsp;hs,&nbsp;"}";
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Note that <TT>"not&nbsp;brace"</TT> matches every token except the curly braces
<TT>"{"</TT> and <TT>"}"</TT>.
<BR>
<BR>
<!--TOC section Predefined schemes-->

<H2 CLASS="section"><A NAME="htoc37">5.3</A>&nbsp;&nbsp;Predefined schemes</H2><!--SEC END -->

<A NAME="sec:stdenv"></A>

Note that the predefined rules are left-recursive and `run' using
constant stack space. Also note that we define rules for arity zero
and arity one (the arity specifies the number of attributes/semantic
values). The primed versions of the rules work on Hughes's efficient
sequence type (a sequence of <TT>a</TT>'s is represented by a function of
type <TT>[a]&nbsp;-&gt;&nbsp;[a]</TT>).<BR>
<BR>
<!--TOC subsection Optional elements-->

<H3 CLASS="subsection"><A NAME="htoc38">5.3.1</A>&nbsp;&nbsp;Optional elements</H3><!--SEC END -->


Arity zero.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;opt&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;opt&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;x;
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Arity one.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;opt&nbsp;x&nbsp;&nbsp;{<I>Maybe</I></TT><TT>&nbsp;a}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x&nbsp;{a};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;opt&nbsp;x&nbsp;&nbsp;{<I>Nothing</I></TT><TT>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<I>Just</I></TT><TT>&nbsp;a}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;x&nbsp;{a};
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<!--TOC subsection Repetition of elements-->

<H3 CLASS="subsection"><A NAME="htoc39">5.3.2</A>&nbsp;&nbsp;Repetition of elements</H3><!--SEC END -->


Arity zero.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;many&nbsp;x,&nbsp;x;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many1&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many1&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;x,&nbsp;many&nbsp;x;
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Arity one.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many&nbsp;x&nbsp;&nbsp;{[a]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x&nbsp;{a};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many&nbsp;x&nbsp;&nbsp;{s&nbsp;[]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;many'&nbsp;x&nbsp;{s};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many'&nbsp;x&nbsp;&nbsp;{[a]&nbsp;-&gt;&nbsp;[a]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x&nbsp;{a};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many'&nbsp;x&nbsp;&nbsp;{\&nbsp;as&nbsp;-&gt;&nbsp;as}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\&nbsp;as&nbsp;-&gt;&nbsp;s&nbsp;(a&nbsp;:&nbsp;as)}&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;many'&nbsp;x&nbsp;{s},&nbsp;x&nbsp;{a};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many1&nbsp;x&nbsp;&nbsp;{[a]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x&nbsp;{a};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;many1&nbsp;x&nbsp;&nbsp;{a&nbsp;:&nbsp;as}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;x&nbsp;{a},&nbsp;many&nbsp;x&nbsp;{as};
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<!--TOC subsection Repetition of elements separated by a second element-->

<H3 CLASS="subsection"><A NAME="htoc40">5.3.3</A>&nbsp;&nbsp;Repetition of elements separated by a second element</H3><!--SEC END -->


Arity zero.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;sepBy&nbsp;x&nbsp;sep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x,&nbsp;sep;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;sepBy&nbsp;x&nbsp;sep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;sepBy1&nbsp;x&nbsp;sep;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;sepBy1&nbsp;x&nbsp;sep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x,&nbsp;sep;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;sepBy1&nbsp;x&nbsp;sep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;x;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;sepBy1&nbsp;x&nbsp;sep,&nbsp;sep,&nbsp;x;
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Arity one.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;sepBy&nbsp;x&nbsp;sep&nbsp;&nbsp;{[a]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x&nbsp;{a},&nbsp;sep;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;sepBy&nbsp;x&nbsp;sep&nbsp;&nbsp;{[]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{as}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;sepBy1&nbsp;x&nbsp;sep&nbsp;{as};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;sepBy1&nbsp;x&nbsp;sep&nbsp;&nbsp;{[a]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x&nbsp;{a},&nbsp;sep;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;sepBy1&nbsp;x&nbsp;sep&nbsp;&nbsp;{s&nbsp;[]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;sepBy1'&nbsp;x&nbsp;sep&nbsp;{s};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;sepBy1'&nbsp;x&nbsp;sep&nbsp;&nbsp;{[a]&nbsp;-&gt;&nbsp;[a]}&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x&nbsp;{a},&nbsp;sep;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;sepBy1'&nbsp;x&nbsp;sep</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\&nbsp;as&nbsp;-&gt;&nbsp;a&nbsp;:&nbsp;as}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;x&nbsp;{a};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\&nbsp;as&nbsp;-&gt;&nbsp;s&nbsp;(a&nbsp;:&nbsp;as)}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;sepBy1'&nbsp;x&nbsp;sep&nbsp;{s},&nbsp;sep,&nbsp;x&nbsp;{a};
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
TODO: also versions where <TT>sep</TT> has arity one.<BR>
<BR>
<!--TOC subsection Repetition of possibly empty elements separated by a second element-->

<H3 CLASS="subsection"><A NAME="htoc41">5.3.4</A>&nbsp;&nbsp;Repetition of possibly empty elements separated by a second element</H3><!--SEC END -->


&lang;<B>To do:</B>&nbsp;better name.&rang;<BR>
<BR>
Arity zero.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;optSepBy&nbsp;x&nbsp;sep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x,&nbsp;sep;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;optSepBy&nbsp;x&nbsp;sep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;x;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;optSepBy&nbsp;x&nbsp;sep,&nbsp;sep;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;optSepBy&nbsp;x&nbsp;sep,&nbsp;sep,&nbsp;x;
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
Arity one.

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;optSepBy&nbsp;x&nbsp;sep&nbsp;&nbsp;{[a]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x&nbsp;{a},&nbsp;sep;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;optSepBy&nbsp;x&nbsp;sep&nbsp;&nbsp;{s&nbsp;[]}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;optSepBy'&nbsp;x&nbsp;sep&nbsp;{s};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;optSepBy'&nbsp;x&nbsp;sep&nbsp;&nbsp;{[a]&nbsp;-&gt;&nbsp;[a]}&nbsp;&nbsp;&lt;-&nbsp;&nbsp;x&nbsp;{a},&nbsp;sep;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;optSepBy'&nbsp;x&nbsp;sep</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\&nbsp;as&nbsp;-&gt;&nbsp;as}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\&nbsp;as&nbsp;-&gt;&nbsp;a&nbsp;:&nbsp;as}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;x&nbsp;{a};</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\&nbsp;as&nbsp;-&gt;&nbsp;s&nbsp;as}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;optSepBy'&nbsp;x&nbsp;sep&nbsp;{s},&nbsp;sep;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\&nbsp;as&nbsp;-&gt;&nbsp;s&nbsp;(a&nbsp;:&nbsp;as)}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;optSepBy'&nbsp;x&nbsp;sep&nbsp;{s},&nbsp;sep,&nbsp;x&nbsp;{a};
</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<!--TOC section Output formats-->

<H2 CLASS="section"><A NAME="htoc42">5.4</A>&nbsp;&nbsp;Output formats</H2><!--SEC END -->

<A NAME="sec:formats"></A>

&lang;<B>To do:</B>&nbsp;Used type names: <TT><I>Result</I></TT> and <TT><I>Terminal</I></TT>.&rang;<BR>
<BR>
&lang;<B>To do:</B>&nbsp;Used function names: <TT>frown</TT>. For each start symbol a parser.&rang;<BR>
<BR>
The <TT>code=standard</TT> format is due to Doaitse Swierstra [<A HREF="#DuS00Fun"><CITE>1</CITE></A>].<BR>
<BR>
The <TT>code=stackless</TT> format is due to Ross Paterson [<A HREF="#HiP05Typ"><CITE>2</CITE></A>].<BR>
<BR>
The <TT>code=gvstack</TT> format is also due to Ross Paterson.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Paren</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Result</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT>{- frown :-( -}</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>data</B>&nbsp;<I>Stack</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Empty</I></TT><TT>&nbsp;|&nbsp;<I>T_1</I></TT><TT>&nbsp;<I>State</I></TT><TT>&nbsp;<I>Stack</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>data</B>&nbsp;<I>State</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>S_1</I></TT><TT>&nbsp;|&nbsp;<I>S_2</I></TT><TT>&nbsp;|&nbsp;<I>S_3</I></TT><TT>&nbsp;|&nbsp;<I>S_4</I></TT><TT>&nbsp;|&nbsp;<I>S_5</I></TT><TT>&nbsp;|&nbsp;<I>S_6</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>data</B>&nbsp;<I>Nonterminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<I>Paren</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;tr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_1&nbsp;tr&nbsp;<I>Empty</I></TT><TT>&nbsp;&gt;&gt;=&nbsp;(\&nbsp;<I>Paren</I></TT><TT>&nbsp;-&gt;&nbsp;return&nbsp;())</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;parse_1&nbsp;ts&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;reduce_2&nbsp;ts&nbsp;<I>S_1</I></TT><TT>&nbsp;st</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;parse_2&nbsp;tr@[]&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_3&nbsp;tr&nbsp;(<I>T_1</I></TT><TT>&nbsp;<I>S_2</I></TT><TT>&nbsp;st)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;parse_2&nbsp;('('</TT><TT>&nbsp;:&nbsp;tr)&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_5&nbsp;tr&nbsp;(<I>T_1</I></TT><TT>&nbsp;<I>S_2</I></TT><TT>&nbsp;st)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;parse_2&nbsp;ts&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;frown&nbsp;ts</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;parse_3&nbsp;ts&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;reduce_1&nbsp;ts&nbsp;st</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;parse_4&nbsp;('('</TT><TT>&nbsp;:&nbsp;tr)&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_5&nbsp;tr&nbsp;(<I>T_1</I></TT><TT>&nbsp;<I>S_4</I></TT><TT>&nbsp;st)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;parse_4&nbsp;(')'</TT><TT>&nbsp;:&nbsp;tr)&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_6&nbsp;tr&nbsp;(<I>T_1</I></TT><TT>&nbsp;<I>S_4</I></TT><TT>&nbsp;st)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;parse_4&nbsp;ts&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;frown&nbsp;ts</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;parse_5&nbsp;ts&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;reduce_2&nbsp;ts&nbsp;<I>S_5</I></TT><TT>&nbsp;st</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;parse_6&nbsp;ts&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;reduce_3&nbsp;ts&nbsp;st</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;reduce_1&nbsp;ts&nbsp;(<I>T_1</I></TT><TT>&nbsp;_&nbsp;(<I>T_1</I></TT><TT>&nbsp;s&nbsp;st))&nbsp;&nbsp;=&nbsp;&nbsp;return&nbsp;<I>Paren</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;reduce_2&nbsp;ts&nbsp;s&nbsp;st&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;goto_5&nbsp;s&nbsp;ts&nbsp;(<I>T_1</I></TT><TT>&nbsp;s&nbsp;st)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;reduce_3&nbsp;ts&nbsp;(<I>T_1</I></TT><TT>&nbsp;_&nbsp;(<I>T_1</I></TT><TT>&nbsp;_&nbsp;(<I>T_1</I></TT><TT>&nbsp;_&nbsp;(<I>T_1</I></TT><TT>&nbsp;s&nbsp;st))))</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;goto_5&nbsp;s&nbsp;ts&nbsp;(<I>T_1</I></TT><TT>&nbsp;s&nbsp;st)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;goto_5&nbsp;<I>S_1</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_2</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;goto_5&nbsp;<I>S_5</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;parse_4</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT>{- )-: frown -}</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;fail&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<DIV CLASS="center">Figure 5.1: <A NAME="fig:ex1cc"></A><TT>frown&nbsp;--code=compact&nbsp;Paren.g</TT>.</DIV><BR>
<BR>

<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Paren</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Result</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT>{- frown :-( -}</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;tr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;state_1&nbsp;(\&nbsp;_&nbsp;-&gt;&nbsp;return&nbsp;())&nbsp;tr</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;state_1&nbsp;k_1_0&nbsp;ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<B>let</B>&nbsp;{&nbsp;goto_paren&nbsp;=&nbsp;state_2&nbsp;k_1_0&nbsp;(reduce_3&nbsp;goto_paren)&nbsp;}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>in</B>&nbsp;reduce_2&nbsp;goto_paren&nbsp;ts</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;state_2&nbsp;k_1_1&nbsp;k_3_1&nbsp;ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<B>case</B>&nbsp;ts&nbsp;<B>of</B>&nbsp;{&nbsp;&nbsp;tr@[]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;state_3&nbsp;k_1_1&nbsp;tr;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'('</TT><TT>&nbsp;:&nbsp;tr&nbsp;&nbsp;-&gt;&nbsp;state_5&nbsp;k_3_1&nbsp;tr;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;frown&nbsp;ts&nbsp;}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;state_3&nbsp;k_1_2&nbsp;ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;k_1_2&nbsp;ts</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;state_4&nbsp;k_3_1&nbsp;k_3_3&nbsp;ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<B>case</B>&nbsp;ts&nbsp;<B>of</B>&nbsp;{&nbsp;&nbsp;'('</TT><TT>&nbsp;:&nbsp;tr&nbsp;&nbsp;-&gt;&nbsp;state_5&nbsp;k_3_1&nbsp;tr;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;')'</TT><TT>&nbsp;:&nbsp;tr&nbsp;&nbsp;-&gt;&nbsp;state_6&nbsp;k_3_3&nbsp;tr;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;frown&nbsp;ts&nbsp;}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;state_5&nbsp;k_3_2&nbsp;ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<B>let</B>&nbsp;{&nbsp;goto_paren&nbsp;=&nbsp;state_4&nbsp;(reduce_3&nbsp;goto_paren)&nbsp;k_3_2&nbsp;}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>in</B>&nbsp;reduce_2&nbsp;goto_paren&nbsp;ts</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;state_6&nbsp;k_3_4&nbsp;ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;k_3_4&nbsp;ts</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;reduce_2&nbsp;g&nbsp;ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;g&nbsp;ts</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;reduce_3&nbsp;g&nbsp;ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;g&nbsp;ts</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT>{- )-: frown -}</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;fail&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<DIV CLASS="center">Figure 5.2: <A NAME="fig:ex1cs"></A><TT>frown&nbsp;--code=stackless&nbsp;Paren.g</TT>.</DIV><BR>
<BR>

<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<TABLE BORDER="2" BGCOLOR="#E0E0E0" WIDTH="100%"><TR><TD>
<TABLE border=0 cellspacing=0 cellpadding=0>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>module</B>&nbsp;<I>Paren</I></TT><TT>&nbsp;<B>where</B></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>import</B>&nbsp;<I>Result</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT>{- frown :-( -}</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>data</B>&nbsp;<I>Nonterminal</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<I>Paren'</I></TT><TT>&nbsp;|&nbsp;<I>Paren</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>type</B>&nbsp;<I>Parser</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;[<I>Terminal</I></TT><TT>]&nbsp;-&gt;&nbsp;<I>Result</I></TT><TT>&nbsp;<I>Nonterminal</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;<B>type</B>&nbsp;<I>VStack</I></TT><TT>&nbsp;vs&nbsp;v&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;((vs,&nbsp;<I>Nonterminal</I></TT><TT>&nbsp;-&gt;&nbsp;<I>Parser</I></TT><TT>),&nbsp;v)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;paren&nbsp;tr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;state_1&nbsp;()&nbsp;tr&nbsp;&gt;&gt;=&nbsp;(\&nbsp;<I>Paren'</I></TT><TT>&nbsp;-&gt;&nbsp;return&nbsp;())</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;state_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;vs&nbsp;-&gt;&nbsp;<I>Parser</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;state_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;state&nbsp;action_1&nbsp;goto_1</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;action_1&nbsp;t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;reduce_2</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;goto_1&nbsp;<I>Paren</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;goto&nbsp;state_2&nbsp;()</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;state_2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>VStack</I></TT><TT>&nbsp;vs&nbsp;()&nbsp;-&gt;&nbsp;<I>Parser</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;state_2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;state&nbsp;action_2&nbsp;undefined</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;action_2&nbsp;t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;<B>case</B>&nbsp;t&nbsp;<B>of</B>&nbsp;{&nbsp;&nbsp;'('</TT><TT>&nbsp;&nbsp;-&gt;&nbsp;shift&nbsp;state_5&nbsp;();</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'$'</TT><TT>&nbsp;&nbsp;-&gt;&nbsp;shift&nbsp;state_3&nbsp;();</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;error&nbsp;}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;state_3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>VStack</I></TT><TT>&nbsp;(<I>VStack</I></TT><TT>&nbsp;vs&nbsp;())&nbsp;()&nbsp;-&gt;&nbsp;<I>Parser</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;state_3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;state&nbsp;action_3&nbsp;undefined</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;action_3&nbsp;t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;reduce_1</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;state_4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>VStack</I></TT><TT>&nbsp;(<I>VStack</I></TT><TT>&nbsp;(<I>VStack</I></TT><TT>&nbsp;vs&nbsp;())&nbsp;())&nbsp;()&nbsp;-&gt;&nbsp;<I>Parser</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;state_4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;state&nbsp;action_4&nbsp;undefined</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;action_4&nbsp;t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<B>case</B>&nbsp;t&nbsp;<B>of</B>&nbsp;{&nbsp;&nbsp;'('</TT><TT>&nbsp;&nbsp;-&gt;&nbsp;shift&nbsp;state_5&nbsp;();</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;')'</TT><TT>&nbsp;&nbsp;-&gt;&nbsp;shift&nbsp;state_6&nbsp;();</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;error&nbsp;}</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;state_5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>VStack</I></TT><TT>&nbsp;(<I>VStack</I></TT><TT>&nbsp;vs&nbsp;())&nbsp;()&nbsp;-&gt;&nbsp;<I>Parser</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;state_5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;state&nbsp;action_5&nbsp;goto_5</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;action_5&nbsp;t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;reduce_2</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;goto_5&nbsp;<I>Paren</I></TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;goto&nbsp;state_4&nbsp;()</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;state_6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;::&nbsp;&nbsp;<I>VStack</I></TT><TT>&nbsp;(<I>VStack</I></TT><TT>&nbsp;(<I>VStack</I></TT><TT>&nbsp;(<I>VStack</I></TT><TT>&nbsp;vs&nbsp;())&nbsp;())&nbsp;())&nbsp;()&nbsp;-&gt;&nbsp;<I>Parser</I></TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;state_6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;state&nbsp;action_6&nbsp;undefined</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;action_6&nbsp;t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;reduce_3</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;reduce_1&nbsp;(((((_,&nbsp;g),&nbsp;()),&nbsp;_),&nbsp;()),&nbsp;_)&nbsp;ts&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;accept&nbsp;<I>Paren'</I></TT><TT>&nbsp;ts</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;reduce_2&nbsp;(_,&nbsp;g)&nbsp;ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;g&nbsp;<I>Paren</I></TT><TT>&nbsp;ts</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;reduce_3&nbsp;(((((((((_,&nbsp;g),&nbsp;()),&nbsp;_),&nbsp;()),&nbsp;_),&nbsp;()),&nbsp;_),&nbsp;()),&nbsp;_)&nbsp;ts&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;g&nbsp;<I>Paren</I></TT><TT>&nbsp;ts</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;state&nbsp;action&nbsp;goto&nbsp;vs&nbsp;ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;<B>let</B>&nbsp;{&nbsp;gs&nbsp;=&nbsp;(vs,&nbsp;g);&nbsp;g&nbsp;v&nbsp;=&nbsp;goto&nbsp;v&nbsp;gs&nbsp;}&nbsp;<B>in</B>&nbsp;action&nbsp;(head&nbsp;ts)&nbsp;gs&nbsp;ts</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;shift&nbsp;state&nbsp;v&nbsp;vs&nbsp;ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;state&nbsp;(vs,&nbsp;v)&nbsp;(tail&nbsp;ts)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;shift'&nbsp;state&nbsp;v&nbsp;vs&nbsp;ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;state&nbsp;(vs,&nbsp;v)&nbsp;ts</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;accept&nbsp;v&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;return&nbsp;v</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;goto&nbsp;state&nbsp;v&nbsp;vs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;state&nbsp;(vs,&nbsp;v)</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;error&nbsp;gs&nbsp;ts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;frown&nbsp;ts</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT>{- )-: frown -}</TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>&gt;&nbsp;&nbsp;frown&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;fail&nbsp;"syntax&nbsp;error"</TT></TD>
</TR></TABLE>

</TD></TR></TABLE><P>
<BR>
<BR>
<DIV CLASS="center">Figure 5.3: <A NAME="fig:ex1cg"></A><TT>frown&nbsp;--code=gvstack&nbsp;Paren.g</TT> (requires an explicit EOF symbol).</DIV><BR>
<BR>

<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
<!--TOC section Invocation and options-->

<H2 CLASS="section"><A NAME="htoc43">5.5</A>&nbsp;&nbsp;Invocation and options</H2><!--SEC END -->

<A NAME="sec:options"></A>

<TT>Usage:&nbsp;frown&nbsp;[option&nbsp;...]&nbsp;file.g&nbsp;...</TT>
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description">
<B><TT>-b</TT> or <TT>--backtrack</TT></B><DD CLASS="dd-description"><BR>
generate a backtracking parser (see Sec.&nbsp;<A HREF="#sec:backtracking">3.2.5</A>)<BR>
<BR>
<DT CLASS="dt-description"><B><TT>-cc</TT>, <TT>-ccompact</TT> or <TT>--code=compact</TT></B><DD CLASS="dd-description"><BR>
(see Sec.&nbsp;<A HREF="#sec:optimizations">3.4.5</A> and&nbsp;<A HREF="#sec:formats">5.4</A>)<BR>
<BR>
<DT CLASS="dt-description"><B><TT>-cg</TT>, <TT>-cgvstack</TT> or <TT>--code=gvstack</TT></B><DD CLASS="dd-description"><BR>
(see Sec.&nbsp;<A HREF="#sec:optimizations">3.4.5</A> and&nbsp;<A HREF="#sec:formats">5.4</A>)<BR>
<BR>
<DT CLASS="dt-description"><B><TT>-cs</TT>, <TT>-cstackless</TT> or <TT>--code=stackless</TT></B><DD CLASS="dd-description"><BR>
(see Sec.&nbsp;<A HREF="#sec:optimizations">3.4.5</A> and&nbsp;<A HREF="#sec:formats">5.4</A>)<BR>
<BR>
<DT CLASS="dt-description"><B><TT>-cstandard</TT> or <TT>--code=standard</TT></B><DD CLASS="dd-description"><BR>
(see Sec.&nbsp;<A HREF="#sec:optimizations">3.4.5</A> and&nbsp;<A HREF="#sec:formats">5.4</A>)<BR>
<BR>
<DT CLASS="dt-description"><B><TT>--copying</TT></B><DD CLASS="dd-description"><BR>
display details of copying<BR>
<BR>
<DT CLASS="dt-description"><B><TT>-d</TT> or <TT>--debug</TT></B><DD CLASS="dd-description"><BR>
emit debugging information (see Sec.&nbsp;<A HREF="#sec:tracing">3.4.4</A>)<BR>
<BR>
<DT CLASS="dt-description"><B><TT>-e</TT> or <TT>--expected</TT></B><DD CLASS="dd-description"><BR>
pass a list of expected terminals to `<TT>frown</TT>' (see Sec.&nbsp;<A HREF="#sec:expected">3.3.3</A>)<BR>
<BR>
<DT CLASS="dt-description"><B><TT>-g</TT> or <TT>--ghc</TT></B><DD CLASS="dd-description"><BR>
use GHC extensions (see Sec.&nbsp;<A HREF="#sec:optimizations">3.4.5</A>)<BR>
<BR>
<DT CLASS="dt-description"><B><TT>-h</TT>, <TT>-?</TT> or <TT>--help</TT></B><DD CLASS="dd-description"><BR>
<DT CLASS="dt-description"><B><TT>-i</TT> or <TT>--info</TT></B><DD CLASS="dd-description"><BR>
put additional information into generated file (see Sec.&nbsp;<A HREF="#sec:tracing">3.4.4</A>)<BR>
<BR>
<DT CLASS="dt-description"><B><TT>-k[nat]</TT> or <TT>--lookahead[=nat]</TT></B><DD CLASS="dd-description"><BR>
use <I>k</I> tokens of look-ahead (see Sec.&nbsp;<A HREF="#sec:look-ahead">3.4.3</A>)<BR>
<BR>
<DT CLASS="dt-description"><B><TT>-l</TT> or <TT>--lexer</TT></B><DD CLASS="dd-description"><BR>
use a monadic lexer (<TT>get&nbsp;::&nbsp;<I>M</I></TT><TT>&nbsp;<I>Terminal</I></TT>) (see Sec.&nbsp;<A HREF="#sec:mlexer">3.3.1</A>)<BR>
<BR>
<DT CLASS="dt-description"><B><TT>-n</TT> or <TT>--noinline</TT></B><DD CLASS="dd-description"><BR>
generate <TT>NOINLINE</TT> pragmas (see Sec.&nbsp;<A HREF="#sec:optimizations">3.4.5</A>)<BR>
<BR>
<DT CLASS="dt-description"><B><TT>-O</TT> or <TT>--optimize&nbsp;</TT></B><DD CLASS="dd-description"><BR>
optimize parser (see Sec.&nbsp;<A HREF="#sec:optimizations">3.4.5</A>)<BR>
<BR>
<DT CLASS="dt-description"><B><TT>-p[nat]</TT> or <TT>--pagewidth[=nat]</TT></B><DD CLASS="dd-description"><BR>
use the specified pagewidth for pretty printing (see Sec.&nbsp;<A HREF="#sec:tracing">3.4.4</A>)<BR>
<BR>
<DT CLASS="dt-description"><B><TT>--prefix[=string]</TT></B><DD CLASS="dd-description"><BR>
use prefix for <FONT COLOR=purple>Frown</FONT>-generated variables (see Sec.&nbsp;<A HREF="#sec:tracing">3.4.4</A>)<BR>
<BR>
<DT CLASS="dt-description"><B><TT>-sm</TT>, <TT>-smono</TT> or <TT>--signature=mono</TT></B><DD CLASS="dd-description"><BR>
add monomorphic type signatures (see Sec.&nbsp;<A HREF="#sec:optimizations">3.4.5</A>)<BR>
<BR>
<DT CLASS="dt-description"><B><TT>-sp</TT>, <TT>-spoly</TT> or <TT>--signature=poly</TT></B><DD CLASS="dd-description"><BR>
add polymorphic type signatures (see Sec.&nbsp;<A HREF="#sec:optimizations">3.4.5</A>)<BR>
<BR>
<DT CLASS="dt-description"><B><TT>--suffix[=string]</TT></B><DD CLASS="dd-description"><BR>
use suffix for frown generated variables (see Sec.&nbsp;<A HREF="#sec:tracing">3.4.4</A>)<BR>
<BR>
<DT CLASS="dt-description"><B><TT>-t</TT> or <TT>--trace</TT></B><DD CLASS="dd-description"><BR>
insert calls to tracing routines (`<TT>shift</TT>', `<TT>reduce</TT>' and `<TT>accept</TT>')
 (see Sec.&nbsp;<A HREF="#sec:tracing">3.4.4</A>)<BR>
<BR>
<DT CLASS="dt-description"><B><TT>-v</TT> or <TT>--verbose</TT></B><DD CLASS="dd-description"><BR>
be verbose<BR>
<BR>
<DT CLASS="dt-description"><B><TT>--version</TT></B><DD CLASS="dd-description"><BR>
print version information<BR>
<BR>
<DT CLASS="dt-description"><B><TT>--warranty</TT></B><DD CLASS="dd-description"><BR>
display details of warranty
</DL>

<!--TOC chapter References-->

<H1 CLASS="chapter">References</H1><!--SEC END -->
<DL CLASS="list" COMPACT="compact"><DT CLASS="dt-list"><A NAME="DuS00Fun"><FONT COLOR=purple>[1]</FONT></A><DD CLASS="dd-list">
Luc Duponcheel and Doaitse Swierstra.
A functional program for generating efficient functional LALR(1)
 parsers, September 2000.
unpublished note.<BR>
<BR>
<DT CLASS="dt-list"><A NAME="HiP05Typ"><FONT COLOR=purple>[2]</FONT></A><DD CLASS="dd-list">
Ralf Hinze and Ross Paterson.
Derivation of a typed functional LR parser, 2005.
in submission.<BR>
<BR>
<DT CLASS="dt-list"><A NAME="Hug86Nov"><FONT COLOR=purple>[3]</FONT></A><DD CLASS="dd-list">
R.&nbsp;John&nbsp;Muir Hughes.
A novel representation of lists and its application to the function
 &#8220;reverse&#8221;.
<EM>Information Processing Letters</EM>, 22(3):141&ndash;144, March 1986.</DL>

<BR>
<BR>
<DIV CLASS="center">
<IMG SRC="Manual002.gif">
</DIV><BR>
<BR>
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://pauillac.inria.fr/~maranget/hevea/index.html"><EM>H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
